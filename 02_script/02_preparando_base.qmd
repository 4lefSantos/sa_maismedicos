---
title: "sa_fluxo_migratorio"
format: html
editor: visual
---

# Churn Prediction: Programa Mais Médicos para o Brasil (PMMB)

O objetivo desse trabalho é realizar uma análise do Programa Mais Médicos para o Brasil referente ao 18º Ciclo (EDITAL Nº 11, DE 10 DE MAIO DE 2019), o programa é direcionado para atenção básica de saúde.

O programa prevê vigência de três anos e a seleção é estruturada em **duas fases**:

1ª. Destinado a formados e revalidados em instituições brasileiras.\
2ª. Destinação das vagas remanescentes para habilitados médicos no exterior (médico intercambista).

O médico indica **quatro localidades em ordem de preferência**. A concorrência se dará entre os profissionais que marcaram o maior grau de preferência, isto é, entre os que marcaram como primeira opção, na ausência, entre os segunda opção e assim sucessivamente.

Entre os **critérios de classificação** estão:

\- Título de Especialista e/ou Residência em Medicina da Família e Comunidade;\
- Atuação como médico em Equipe de Saúde da Família;\
- Ter sido bolsista do Programa de Educação pelo Trabalho para a Saúde (PET);\
- Ter participado como estagiário em alguma edição da Vivência e Estágio na Realidade - do SUS (VER-SUS).

**Em caso de empate**, impera os seguintes critérios conforme ordem a seguir:

\- Candidatos que já atuaram no Programa Mais Médicos para o Brasil;\
- Maior idade;\
- Data de formação.

No caso dos médicos intercambistas, além de auto-declarar conhecimento mínimo na lingua portuguesa, precisam ser aprovados no **Módulo de Acolhimento e Avaliação**. O módulo é executado em Brasília/DF, na modalidade presencial, com carga horária mínima de 160 horas. Contempla conteúdo relacionado à legislação referente ao SUS, notadamente da Atenção Básica em Saúde, aos protocolos clínicos de atendimento definidos pelo Ministério da Saúde, à Língua Portuguesa e ao Código de Ética Médica.

Após aprovação, o médico deverá se apresentar no período indicado, no município de alocação, perante o gestor municipal, portando 2 (duas) vias do Termo de Adesão e Compromisso.

Já em exercício, o médico deverá cumprir **carga horária de 40 horas** semanalmente, 8 horas em atividades acadêmicas teóricas e 32 horas em atividades nas unidades básicas de saúde no Município.

O edital não é taxativo em proibir outros vínculos profissionais, desde que seja compatível com a carga horária do programa. Veja:

2.2.5. Não possuir vínculo de serviço com carga horária incompatível com as exigências do Projeto\*;

\
\* Mediante declaração, que ficará registrada no Termo de Aceite, quando do preenchimento do formulário de adesão.

Abaixo os pacotes que serão necessários.

```{r}
#|warning: FALSE

library(tidyverse)
library(readxl)
library(geosphere)
library(TraMineR)
library(TraMineRextras)
library(factoextra)
library(genderBR)
library(lubridate)
library(writexl)
library(RODBC)
library(estimatr)
library(plm)
library(patchwork)
library(geobr)
library(sf)
library(scales)
library(rstatix)
library(ggalluvial)


```

## 1. Montagem da base de dados.

Seguindo o objetivo do script, a elaboração da base de dados com os fatores (variáveis) relacionados aos médicos participantes do programa seguirá a seguinte estrutura:

1.1 **Tratamento preliminar**: A partir da identificação dos médicos por meio de webscraping, realiza-se a validação dos profissionais empossados com base no levantamento do histórico profissional.

1.2 **Atributos a nível individuo**: São levantadas as variáveis relacionados aos médicos de forma individualizada.

1.3 **Atributos a nível estabelecimento**: São levantadas as variáveis que caracterizam os estabelecimentos de saúde que receberam médicos do programa.

1.4 **Atributos a nível município**: São levantadas as variáveis que caracterizam os municípios que receberam médicos do programa.

Conforme estrutura mencionada, a elaboração inicia com o tratamento preliminar que é realizado logo a seguir.

## 1.1. Tratamento de dados do Mais Médicos

A primeira etapa consiste na elaboração da base de dados com tratamento do Mais Médicos.

A partir dos resultados do edital do 18º Ciclo do PMMB, identificamos os médicos e realizamos o processo de *web scrapping* para identificar o CNS desses profissionais no site CNES.

Após a transformação em planilha dos resultados do edital e a identificação do CNS pela raspagem, abriremos esses dados que representam 2452 médicos. Para alguns médicos, não foi possível identificar o número de CNS (265 médicos). Isso ocorre devido à presença de homônimos.

```{r}

cns_inscricao <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/Edital_11_2019_resultado_cns.xlsx") |> 
  select(nome, 
         uf_aloc, 
         municipio_aloc, 
         ibge_aloc,
         participou_pmmb, 
         data_nascimento,
         data_formacao, 
         fase, 
         resultado) |> 
  rename(cns = resultado) |> 
  rename(municipio_destino = municipio_aloc) |> 
  rename(uf_destino = uf_aloc) |> 
  mutate(cns = as.character(cns)) |>  
  filter(!is.na(cns))

#Como o registro CNS de dois médicos gerados pela raspagem ser proveniente de uma falha, iremos atualizar com os números CNS corretos que retornam registros.

cns_inscricao$cns <- gsub("709009835268418",
                          "980016294141538", 
                          cns_inscricao$cns)

cns_inscricao$cns <- gsub("700301975418435",
                          "100001866830003",
                          cns_inscricao$cns)

```

Com base nesse resultado final, extraímos todos os CNS em um vetor para executar uma consulta no datalake, a fim de identificar os respectivos CPFs. Cabe mencionar que estes CPFs são criptografados, mas que podem ser utilizados como chave de identificação individualizada.

No entanto, houveram dois CNS's que não retornaram registros na consulta: RENATO PINTO DA CUNHA SANTOS (709009835268418) e GILVAN DOREA DANTAS (700301975418435). Para esses casos, foi realizada a consulta pelo nome com o devido confronto com as informações retornadas na página do CNES, e identificados os CNS's e CPF's.

Essa consulta gerou uma base denominada CNES_cns.

Filtraremos essa base a partir da competência 201901 e, em seguida, identificaremos os CPFs únicos para realizar uma nova consulta com esses CPFs, trazendo os dados completos.

``` sql
SELECT a.CNES, 
       b.uf,
       b.uf_sigla, 
       a.CODUFMUN, 
       b.municipio,
       b.latitude,
       b.longitude,
       a.CPF_PROF, 
       a.CBO, 
       a.NOMEPROF, 
       a.CNS_PROF,
       a.VINCULAC, 
       a.HORAOUTR, 
       a.HORAHOSP, 
       a.HORA_AMB, 
       a.COMPETEN
FROM Dados.cnes.PF a
    LEFT JOIN "Analytics Layer".Territorial."Municípios - Hierarquia Completa" b
        ON a.CODUFMUN = CAST(b.cod_municipio AS CHARACTER)
WHERE CNS_PROF IN (lista)
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
                    sprintf("DRIVER=Dremio Connector;
                             HOST=%s;
                             PORT=%s;
                             UID=%s;
                             PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."Consulta_maismedicos_2019_cns"'


CNES_cns <- sqlQuery(channel, query, 
                     as.is = TRUE)

```

```{r}
#identificando os CPF

lista_cpf <- 
  CNES_cns |> 
  filter(COMPETEN >= 201001) |> 
  mutate(CNS_PROF = as.character(CNS_PROF)) |> 
  select(CPF_PROF, CNS_PROF, 
         NOMEPROF) |> 
  distinct(CPF_PROF)

```

Observa-se que a lista de CPF's retornou apenas 2185 observações (duas a menos que o original). Agora já identificada a variável CPF_PROF, executaremos a consulta abaixo para baixar os dados completos dos profissionais pelos respectivos CPF_PROF.

**Observação**: Este procedimento foi realizado, pois nem sempre o CNS é preenchido pelos estabelecimentos. Portanto, optamos por pegar o CPF criptografado, pois o grau de preenchimento possui maior completude.

``` sql
SELECT a.COMPETEN,
       a.CODUFMUN, 
       c.uf_sigla,
       c.municipio_pad,
       a.CNES, 
       b.FANTASIA,
       a.TP_UNID,
       a.CNS_PROF,
       a.CPF_PROF,
       a.NOMEPROF,
       a.PROF_SUS,
       a.vinculac,
       a.HORAHOSP,
       a.HORA_AMB,
       a.HORAOUTR
FROM Dados.cnes.PF a
    LEFT JOIN Dados.cnes.CADGER b
        ON a.CNES = b.CNES
    LEFT JOIN "Analytics Layer".Territorial."Municípios - Hierarquia Completa" c
        ON a.CODUFMUN = CAST(c.cod_municipio AS CHARACTER)
WHERE CPF_PROF IN (lista)
ORDER BY 
    COMPETEN
```

```{r}
#| message: false
#| warning: false
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
              sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."Consulta_maismedicos_2019"'



CNES_cpf <- sqlQuery(channel, 
                     query, 
                     as.is = TRUE)
```

O próximo passo será unir as duas bases:

1\) `cns_inscricao`: obtida a partir do resultado do edital nº 18/2019, pois estas trazem dados sobre o inscrito (ex.: local onde foi alocado, ano de formação)

2\) `CNES_cpf`: base do CNES-PF com o acompanhamento destes indivíduos ao longo do tempo.

No entanto, como a base de inscrição não possui a variável CPF, primeiro será necessário adicioná-la a essa base para, em seguida, realizar um `left_join` com a base CNES_cpf.

```{r}

lista_cns_cpf <- 
        CNES_cns |> 
        filter(COMPETEN >= 201001) |> 
        mutate(CNS_PROF = as.character(CNS_PROF)) |> 
        select(CPF_PROF, CNS_PROF) |> 
        distinct(CPF_PROF, CNS_PROF)

cns_inscricao <- 
  cns_inscricao |> 
  left_join(lista_cns_cpf, 
            by = c("cns" = "CNS_PROF"))

```

Agora adicionada a coluna de CPF na base cns_inscricao, faremos um `left join` entre a base CNES_cpf e ela.

```{r}

base_tratada <- CNES_cpf |> 
                left_join(cns_inscricao, 
                  by = c("CPF_PROF" = "CPF_PROF"))

```

O próximo passo é identificar os médicos que iniciaram no programa. Esse mapeamento será realizado com o atendimento de alguns critérios:

1.  identifica se o médico está na cidade o qual foi designado em algum momento no ano de 2019;

2.  está alocado em uma unidade de atenção básica;

Esse tratamento foi especialmente importante, pois as vezes o profissional chegou a passar no programa, mas não assumiu.

Com essa variável verificaremos qual foi a primeira competência em que essas condições foram satisfeitas. Observa-se que entre junho e novembro de 2019 há um número considerável de médicos migrando para as cidades de designação.

A partir dessa identificação, filtraremos a base apenas com esses médicos.

```{r}

# Convertendo competência para formato data

base_tratada$COMPETEN <- 
  as.Date(paste0(base_tratada$COMPETEN, "01"), 
          format = "%Y%m%d")

# metodo para identificar quem foi selecionado e de fato foi para a cidade a qual foi alocado no programa, inclusive sendo alocado em APS

temp <- 
  base_tratada |> 
    mutate(aps = if_else((TP_UNID == "02" |
                          TP_UNID == "01" |
                          TP_UNID == "32" |
                          TP_UNID == "71" |
                          TP_UNID == "72" |
                          TP_UNID == "74"), 
                         "APS", "Outros")) |> 
  mutate(ano = year(COMPETEN)) |> 
  filter(ano == 2019) |> 
  mutate(assumiu_programa = 
           if_else(ano == 2019 &
                   aps == 'APS' &
                   CODUFMUN == ibge_aloc, 
                   "Foi alocado", 
                   "Não foi alocado")) 

temp2 <- temp |> 
        filter(assumiu_programa == "Foi alocado") |> 
        group_by(CPF_PROF) |> 
        slice_min(COMPETEN, n = 1, with_ties = FALSE)

vetor_saida <- 
  lista_cns_cpf |> 
  anti_join(temp2, by = c("CPF_PROF")) 

dim(vetor_saida)

```

Cerca de 419 indivíduos saíram da base, pois não assumiram o programa. Abaixo temos alguns exemplos.

-   A médica, cujo código CPF criptografado é "\<82\>\<83\>~\<82\>\<80\>~\<80\>}{{", foi designada ao município de José de Freitas (PI). Porém, ao longo do ano de 2019 ela não esteve nenhum mês no município. Os primeiros registros dela após 2019 foram apenas no ano de 2022 em Epitaciolândia (AC).

```{r}

base_tratada |> 
  filter(year(COMPETEN) >= 2019) |> 
  filter(CPF_PROF == "<82><83>~<82><80>~<80>}{{") |> 
   select(COMPETEN, uf_destino,
          municipio_destino, uf_sigla,
          municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

-   A médica, cujo código CPF_PROF é "\<82\>{\<84\>\<83\>\<82\>\~\<83\>\<81\>\<82\>{{", foi designada ao município de Mesquita (RJ). Porém, ao longo do ano de 2019 ela não esteve nenhum mês no município. No ano de 2019 ela estava atuando unicamente no Rio de Janeiro (RJ).

```{r}

base_tratada |> 
  filter(year(COMPETEN) >= 2019) |> 
  filter(CPF_PROF == "<82>{<84><83><82>~<83><81><82>{{") |> 
  select(COMPETEN, uf_destino, municipio_destino, uf_sigla,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

-   A médica, cujo código CPF_PROF é "\~}}\|\|}}}{", foi designada ao município de Alvorada (RS). Porém, ao longo do ano de 2019 ela não esteve nenhum mês no município. No ano de 2019 ela estava atuando unicamente em Rio Branco (AC).

```{r}

base_tratada |> 
  filter(year(COMPETEN) >= 2019) |> 
  filter(CPF_PROF == "~}}||}}}{") |> 
  select(COMPETEN, uf_destino, 
         municipio_destino, uf_sigla,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

Logo retirando os 419 casos acima, mantemos 1768 indivíduos na base. Desta forma, mantivemos uma base 222.818 observações.

```{r}

# Filtrando a base apenas com os médicos ingressantes

base_tratada2 <- 
    base_tratada |> 
    filter(CPF_PROF %in% temp2$CPF_PROF) |> 
    janitor::clean_names() |> 
    mutate(ano = year(competen)) |> 
    mutate(ch_total = horahosp + 
                      hora_amb + 
                      horaoutr) |> 
    select(ano, competen, codufmun, cnes, 
           municipio_pad, ibge_aloc, 
           municipio_destino, uf_destino, 
           cnes, tp_unid, fantasia, nomeprof, 
           cns_prof, cpf_prof, 
           data_nascimento, data_formacao, 
           participou_pmmb, 
           ch_total) |>
    filter(competen >= '2019-01-01')

```

## 1.2. Variáveis de desfecho

Criamos duas variáveis de desfecho:

1.  churn (variável dicotômica, permanece ou não no município ao qual foi alocado, após 5 anos);

2.  tempo de permanência (variável quantitativa, medida em meses);

### 1.2.1. Churn

A variável de desfecho foi construída com o objetivo de verificar se a pessoa sai do município onde foi designada cerca de cinco anos após o início do programa (final de 2024). Lembrando que o programa tem duração de 36 meses (3 anos), podendo haver prorrogação por mais um ano.

Cerca de 1203 saiu do município para onde foi alocado e 361 permanecem.

```{r}

churn <- 
  base_tratada2 |> 
  filter(competen == "2024-12-01") |> 
  mutate(churn = 
           if_else(codufmun == ibge_aloc, 
                   "permanece", 
                   "migrou")) |> 
  select(cpf_prof, codufmun, ibge_aloc, churn) |> 
  distinct() 

# Se o individuo estiver atuando no mesmo municipio e em outra localidade limitrofe, vamos marcar como "permanece". Os codigos abaixo servem para termos este controle

churn_permanece <- churn |> 
                    filter(churn == "permanece") |>                     group_by(cpf_prof) |> 
                    slice(1) |> 
                    select(cpf_prof, churn)

churn_migrou <- churn |> 
                      filter(churn == "migrou") |> 
                        group_by(cpf_prof) |> 
                        slice(1)  

teste_churn <-  
  cns_inscricao |> 
    filter(CPF_PROF %in% unique(churn$cpf_prof)) |>
    left_join(churn_permanece,
              by = c("CPF_PROF"="cpf_prof")) |> 
    mutate(churn = if_else(is.na(churn),
                           "migrou",
                           churn))

table(teste_churn$churn)
 
```

É importante observar que o somatório é 1564 (950 migraram + 614 permanecem), ou seja, menor que o número inicial.

Isso decorre, pois alguns profissionais podem ter saído da base (ex.: migrou do país, migrou de atuação, aposentou, óbito, passou a atuar em locais que não possuem registro no CNES).

Abaixo colocamos alguns exemplos que ocorreram isso.

-   O primeiro caso é um profissional identificado por "\<83\>\<82\>\<82\>\|\<81\>\<83\>\<84\>{" que ficou poucos meses em Olinda (PE), município ao qual foi alocado. Porém, os seus registros na base se encerram em maio de 2023.

```{r}

base_tratada |> 
  filter(CPF_PROF == "~<83><82>~<82>|<81><83><84>{") |> 
  filter(year(COMPETEN) >= 2019) |> 
  select(COMPETEN, municipio_destino, uf_destino,
          municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

-   O segundo caso é um profissional identificado por "\<82\>{\<84\>\<84\>}{\<80\>\<82\>\<83\>" que ao final do ano de 2024 não estava mais na base, apesar de ter trabalhado muito tempo em Utinga (BA).

```{r}

base_tratada |> 
  filter(CPF_PROF == "<82>{<84><84>}{<80><82><83>") |> 
  filter(year(COMPETEN) >= 2019) |> 
  select(COMPETEN,
         municipio_destino,
         uf_destino,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

A base a seguir exclui os casos de indivíduos que não estavam atuando mais no final de 2024 (independente de estarem no município onde foram alocados ou não), que resulta em 1564 indivíduos.

```{r}

base_tratada3 <- base_tratada2 |>    
  filter(cpf_prof %in% churn$cpf_prof) 

```

#### 1.2.2.1. Gráfico de sankey

Preparando o gráfico de sankey para visualizar as migrações.

```{r}

migracoes <- teste_churn |> 
  filter(churn == "migrou") |> 
  select(CPF_PROF, 
         ibge_aloc, 
         uf_destino, 
         municipio_destino) |> 
  left_join(churn_migrou, 
            by = c("CPF_PROF"="cpf_prof")) |> 
  janitor::clean_names() |> 
  rename(mun_aloc = ibge_aloc_x,
         uf_aloc = uf_destino,
         municipio_aloc = municipio_destino) |> 
  select(cpf_prof, uf_aloc, mun_aloc,
         municipio_aloc, codufmun, churn)

#write.csv(migracoes,
#          "~/GitHub/sa_maismedicos/01_dados/dados #resultantes/base_grafico_sankey.csv")

```

Vamos agora juntar este df com a base com a classificação dos municípios em termos de porte para depois fazer o sankey plot.

```{r}

pop_mun <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/pop_municipios.xlsx") |> 
  mutate(cod_mun = substr(cod_mun, 1, 6)) |> 
  mutate(populacao = as.numeric(populacao)) |> 
  mutate(porte = 
           case_when((populacao < 20000) ~ "PP-I",
                     (populacao >= 20000 & 
                      populacao < 50000) ~ "PP-II",
                     (populacao >= 50000 & 
                      populacao < 100000) ~ "MP",
                     (populacao >= 100000 & 
                      populacao < 900000) ~ "GP",
                     (populacao >= 900000) ~ "Metrópole",
                      TRUE ~ "Outros casos")) |> 
  select(-populacao)

migracoes$mun_aloc <- as.character(migracoes$mun_aloc)

migracoes_tratado <- 
  migracoes |> 
  left_join(pop_mun, 
            by = c("mun_aloc"="cod_mun")) |> 
  left_join(pop_mun,
            by = c("codufmun"="cod_mun")) |> 
  select(cpf_prof, uf_aloc, mun_aloc, 
         municipio_aloc, porte.x, 
         codufmun, mun.y, porte.y) |> 
  rename(porte_mun_alocado = porte.x,
         porte_mun_migrado = porte.y,
         mun_migrado = mun.y)


```

Agora criando o gráfico de sankey.

```{r}

total_migracoes <- migracoes_tratado |> 
                      group_by(porte_mun_alocado,
                               porte_mun_migrado) |> 
                      summarise(total = n()) 

#write_xlsx(total_migracoes, "~/GitHub/sa_maismedicos/01_dados/dados #resultantes/migracoes_porte.xlsx")

totais_alocado <- migracoes_tratado |> 
  count(porte_mun_alocado, name = "total") 

totais_migrado <- migracoes_tratado |> 
  count(porte_mun_migrado, name = "total") 

a <- migracoes_tratado |> 
  ggplot(aes(axis1 = porte_mun_alocado, 
             axis2 = porte_mun_migrado)) +
    geom_alluvium(aes(fill = porte_mun_alocado)) +
    geom_stratum() +
    geom_text(stat = "stratum", 
              aes(label = after_stat(stratum))) +
    theme_minimal() +
    labs(title = "Fluxo de Migração entre Portes de Municípios",
         y = "Total", 
         x = "Porte do município alocado e Porte do município de destino") +
    theme(axis.text.x = element_blank(),
          legend.title = element_blank())

ggsave("sankey_plot.jpeg", a, dpi = 300,
       width = 6, height = 4)
    
```

### 1.2.2. Tempo de permanência

A variável de desfecho foi construída com o objetivo de verificar se a pessoa sai do município onde foi designada cerca de 5 anos após o início do programa. Lembrando que o programa tem duração de 48 meses.

```{r}

meses_trabalho <-    
  base_tratada3 |>      
  group_by(cpf_prof) |>       
  mutate(         
    meses_no_local_alocado =            
      interval(             
        min(competen[codufmun == ibge_aloc]),       
        max(competen[codufmun == ibge_aloc])) %/%           months(1) + 1) |>       
  ungroup() |>    
  select(cpf_prof,           
         meses_no_local_alocado) |>      
  distinct() 

mean(meses_trabalho$meses_no_local_alocado)

```

-   O exemplo que mostramos anteriormente é evidente quanto a isso. O profissional atuou no município de destino por sete meses, entre agosto de 2019 e fevereiro de 2020. Porém, os últimos registros são este ano. Após isso, não aparece mais na base.

```{r}

base_tratada |> 
  filter(CPF_PROF == "~<83><82>~<82>|<81><83><84>{") |> 
  filter(year(COMPETEN) >= 2019) |> 
  select(COMPETEN, 
         municipio_destino, 
         uf_destino,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  filter(municipio_pad == "OLINDA") |> 
  DT::datatable()

```

A média do tempo de atuação no mesmo local é de aproximadamente 44 meses.

```{r}

a <- meses_trabalho |>    
  ggplot(aes(y = meses_no_local_alocado)) +  
  geom_boxplot() +    
  ylab("Meses no local de trabalho")  

b <- meses_trabalho |>    
  ggplot(aes(x = meses_no_local_alocado)) +   
  geom_histogram() +    
  xlab("Meses no local de trabalho") +   
  ylab("Frequência")  

a + b
```

Aqui vamos começar a organizar a base então. Lembrando que pelo número de observações serão 1460 linhas.

```{r}

base_vd <- 
  cns_inscricao |> 
  filter(CPF_PROF %in% churn$cpf_prof) |> 
  left_join(meses_trabalho,
            by = c("CPF_PROF"="cpf_prof")) |> 
  left_join(churn_permanece,
            by = c("CPF_PROF"="cpf_prof")) |> 
  mutate(churn = if_else(is.na(churn),
                         "migrou",
                         churn))

table(base_vd$churn)

```

Vamos fazer algumas análises exploratórias iniciais.

Percebe-se que em alguns estados houve uma migração mais elevada, que são os casos de Rio Grande do Norte, Sergipe e Alagoas.

```{r}

base_vd |> 
  group_by(churn, uf_destino) |> 
  count() |> 
  ggplot(aes(x = uf_destino, 
             y = n, fill = churn)) +
  geom_col(position = "fill") +
  coord_flip() + 
  xlab("UF") +
  ylab("Percentual migração vs permanência") + 
  theme_minimal()

```

Em relação ao tempo média de permanência, temos o seguinte gráfico.

```{r}

base_vd |> 
  group_by(uf_destino) |> 
  summarise(tempo = mean(meses_no_local_alocado)) |> 
  ggplot(aes(x = fct_reorder(uf_destino, tempo), 
             y = tempo)) +
  geom_col() +
  coord_flip() +
  xlab("UF") + 
  ylab("Tempo médio de permanência") +
  theme_minimal()

```

A partir da próxima seção vamos agregar algumas variáveis a nível indivíduo.

## 1.3. Atributos a nível indivíduo

Vamos começar a levantar alguns atributos a nível indivíduo.

### 1.3.3 Idade

Adicionando a variável de idade. Percebemos que as pessoas que migram, tendem a ser mais novas.

```{r}

base_vd <- base_vd |> 
  mutate(idade = round(interval(data_nascimento,as.Date("2024-12-12"))/years(1)))

base_vd |> 
  group_by(churn) |> 
  summarise(idade_media = mean(idade),
            idade_sd = sd(idade))

```

Os gráficos abaixo ratificam os resultados.

```{r}

base_vd |> 
  ggplot(aes(x = idade, fill = churn)) + 
  geom_histogram(binwidth = 1, 
                 color = "black",
                 alpha = 0.7) +  
  geom_vline(xintercept = 39, 
             linetype = "dashed", 
             color = "black") +  
  geom_vline(xintercept = 45, 
             linetype = "dashed", 
             color = "black") +  
  annotate("text", 
           x = 39, 
           y = Inf, 
           label = "Migrou", 
           vjust = 1.5, 
           hjust = 1.1,
           fontface = "bold") +  
  annotate("text", x = 45, y = Inf, 
           label = "Permanece", 
           vjust = 3.5, 
           hjust = -0.10, 
           fontface = "bold") +  
  theme_minimal()

```

### 1.3.2 Atuação prévia

Vamos acessar para ver se aquele indivíduo atuou na cidade onde foi destinado em anos anteriores a 2019. Além disso, verificamos quantos meses ele atuou nesta localidade.

```{r}

# estou usando 'base_tratada' e nao a 'base_tratada3' pois la retiramos os registros antes de 2019 para fazer uns tratamentos 

atuacao <- 
    base_tratada |> 
    mutate(ano = year(COMPETEN)) |> 
    filter(ano < 2019 & 
             CODUFMUN == ibge_aloc) |> 
    group_by(COMPETEN, ibge_aloc, CPF_PROF) |> 
    count() |> 
    group_by(ibge_aloc, CPF_PROF) |> 
    count() |> 
    mutate(atuacao_previa_no_municipio = "Sim") |> 
    mutate(anos_atuacao_previa_no_municipio = n/12) |> 
    ungroup() |> 
    select(-ibge_aloc)

```

Existem alguns casos que o profissional atuou por mais de 12 anos.

Depois de preparar a base, vamos juntar à base original.

```{r}

base_atributos <- 
      base_vd |> 
      left_join(atuacao, 
                by = c("CPF_PROF")) |> 
      mutate(atuacao_previa_no_municipio = 
             if_else(atuacao_previa_no_municipio == 
                       "Sim","Sim","Não")) |> 
      select(-n) |> 
      janitor::clean_names()

base_atributos$atuacao_previa_no_municipio[is.na(base_atributos$atuacao_previa_no_municipio)] <- "Não"

base_atributos$anos_atuacao_previa_no_municipio[is.na(base_atributos$anos_atuacao_previa_no_municipio)] <- 0

```

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(media = mean(anos_atuacao_previa_no_municipio),
            sd = sd(anos_atuacao_previa_no_municipio))


shapiro.test(base_atributos$anos_atuacao_previa_no_municipio)

wilcox_test(anos_atuacao_previa_no_municipio ~ churn, data = base_atributos, alternative = "two.sided")
```

### 1.3.3 Quantidade média de vínculos enquanto está na mesma cidade

Para isso, vamos verificar, desde de meados de 2019, quantos vínculos o indivíduos tinha por competência no mesmo município onde ele foi alocado.

```{r}

vinculos_cidade <- 
  base_tratada3 |> 
  filter(competen > '2019-05-01') |> 
  group_by(cpf_prof, competen, 
           codufmun, ibge_aloc) |> 
  count() |> 
  ungroup() |> 
  filter(codufmun == ibge_aloc) |> 
  select(cpf_prof, competen, n) |> 
  group_by(cpf_prof) |> 
  summarise(media_vinculos_mes = mean(n))

```

Juntando com a base tratada.

```{r}

base_atributos <- 
  base_atributos |> 
  left_join(vinculos_cidade, 
            by = c("cpf_prof"))

```

-   A maioria dos registros ficou apenas em um só estabelecimento ao longo de todo o período. O profissional identificado pelo código "\<80\>\<84\>\~\~\<80\>}\<83\>\<84\>}\<82\>}" é um bom exemplo. O profissional mudou de unidade (sempre na APS), mas sempre com apenas um vínculo.

```{r}

base_tratada3 |> 
  filter(cpf_prof == "<80><84>~~<80>}<83><84>}<82>}") |> 
  select(competen, 
         uf_destino,
         municipio_destino,
         codufmun,
         municipio_pad,
         fantasia) |> 
  DT::datatable()
  
  

```

-   Em contrapartida, o profissional identificado pelo código "{}\~}}\|\<80\>\<82\>\~" começa a atuar na APS em junho de 2019. Ao longo de todo o período, a pessoa se mantém no mesmo município que foi alocada (Mutum-MG). Inclusive, é o tipo de caso que já atuava antes no mesmo município.

Todos os meses ele atuava no município, vinculado não só a APS, mas outros estabelecimentos.

```{r}

base_tratada3 |> 
  filter(cpf_prof == "{}~}}|<80><82>~") |> 
  select(competen, 
         uf_destino,
         municipio_destino,
         codufmun,
         municipio_pad,
         fantasia,
         ch_total) |> 
  DT::datatable()

```

Observa-se que há maior variedade no número de vínculos entre os profissionais que permaneceram.

```{r}

base_atributos |> 
  ggplot(aes(y = media_vinculos_mes,
             fill = churn)) +
  geom_boxplot() +
  theme_minimal() + 
  ylab("Média de vínculos por mês no\n mesmo local") + 
  theme(axis.text.x = element_blank())
  
```

Os resultados abaixos ratificam os resultados do gráfico.

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(media_vinculos = 
              round(mean(media_vinculos_mes),2),
            sd_vinculos = 
              round(sd(media_vinculos_mes),2))

shapiro.test(base_atributos$media_vinculos_mes)

wilcox_test(media_vinculos_mes ~ churn, data = base_atributos, alternative = "two.sided")
```

### 1.2.6 Renovação

A próxima etapa será identificar os profissionais que tiveram a permanência no programa prorrogada por mais um ano. Infelizmente, como a única informação nos resultados de prorrogação que identifica o médico é o nome, realizaremos o left join utilizando essa variável.

```{r}

prorrogacao <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/prorrogacao_ciclo18.xlsx")

base_atributos <- 
  base_atributos |>   
  left_join(prorrogacao, 
            by = c("nome" = "NOME")) |>   
  mutate(Prorrogado = ifelse(is.na(Prorrogado), 
                             "NÃO", 
                             Prorrogado))

base_atributos |>
  group_by(Prorrogado) |> 
  summarise(quantidade = n()) |> 
  mutate(percentual = round(quantidade/sum(quantidade)* 100,2)) |> 
  DT::datatable()

churn_prorrogou <- table(base_atributos$churn[base_atributos$Prorrogado == "SIM"])
chisq.test(churn_prorrogou)

churn_nprorrogou <- table(base_atributos$churn[base_atributos$Prorrogado == "NÃO"])
chisq.test(churn_nprorrogou)
```

Dos 1564 médicos, 687 (43,91%) tiveram sua adesão prorrogada por mais um ano e 877 (56,07%) não prorrogaram.

Abaixo visualizaremos a informação desagregada por churn. A permanência foi maior entre aqueles que prorrogaram.

```{r}
base_atributos |> 
  group_by(churn, Prorrogado) |> 
  count() |> 
  ggplot(aes(x = Prorrogado, 
             y = n, fill = churn)) +
  geom_col(position = "fill") +
  coord_flip() + 
  theme_minimal()

```

### 1.2.7. Tempo formado

Este atributo é mensurado a partir de dados que estão na próprio resultado de convocação de profissionais.

```{r}

anos_formado <- 
  base_tratada2 |>
  mutate(
    data_formacao = dmy(paste0("01/", data_formacao)), 
    competen = ymd(competen)) |>
  group_by(cpf_prof) |>
  slice_min(order_by = competen, with_ties = FALSE) |>
  ungroup() |>
  mutate(anos_formacao = 
           as.numeric(difftime(competen, 
                               data_formacao,
                               units = "days")) / 365.25) |> 
  mutate(anos_formacao = if_else(anos_formacao < 0, 
                                 0,
                                 anos_formacao)) |> 
  select(cpf_prof, anos_formacao)


base_atributos <- 
  base_atributos |> 
  left_join(anos_formado, 
            by = c("cpf_prof"))


print(paste("Média:", round(mean(anos_formado$anos_formacao),2)))
print(paste("Mediana: ", round(median(anos_formado$anos_formacao),2)))


shapiro.test(base_atributos$anos_formacao)

wilcox_test(anos_formacao ~ churn, data = base_atributos, alternative = "two.sided")
```

A média do tempo de formação são de 5,45 anos, no entanto como há muitos outliers calcula-se também a mediana que é de 1,8 anos, dessa forma, observa-se que a maioria dos médicos tem até 2 anos de formação.

Ao desagregar por churn, observa-se que o tempo de formação é maior entre os permanceram nas cidades em que foram alocados.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = anos_formacao,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Anos") +
  ylab("Anos de formação") + 
  theme_minimal()

b <- base_atributos |>
  ggplot(aes(x= anos_formacao,
             fill = churn)) + 
  geom_histogram() +
  xlab("Anos de formação") +
  ylab("Frequência") + 
  theme_minimal()

a + b
```

A tabela abaixo quantifica a diferença dos anos de formação por churn. Observa-se que a média, mediana e desvio-padrão entre os que migraram é menor.

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(anos_formacao),2),
            mediana = round(median(anos_formacao),2),
            sd = round(sd(anos_formacao),2)) |> 
  DT::datatable()
```

```{r}

wilcox.test(anos_formacao ~ churn, 
            data = base_atributos)

```

## 1.3. Atributos a nível estabelecimento

Nessa seção, serão levantadas as variáveis associadas aos estabelecimentos que receberam médicos do programa, tais como, profissionais de outras categorias profissionais.

O tratamento abaixo é realizado para acessar todos os profissionais que assumiram o programa e as unidades de APS que ele atuou enquanto esteve no município ao qual foi alocado.

```{r}


temp3 <- 
  base_tratada3 |> 
            filter(cpf_prof %in% churn$cpf_prof &
                   tp_unid %in% c("02", "01", "32", 
                                  "71", "72", "74") &
                   codufmun == ibge_aloc) 
                     

```

### 1.3.1 Número de profissionais das unidades

Este passo consiste em identificar qual o número de profissionais nas unidades de APS as quais o indivíduo foi alocado.

``` sql
WITH ch_cnes_selecionados 

AS(
    SELECT CNES,
        CODUFMUN, 
        PF.NOMEPROF,
        PF.CPF_PROF,
        CBO,
        CASE 
            WHEN substr(CBO, 1, 4) = '2235' 
            THEN 'Enfermeiro' 
            WHEN substr(CBO, 1, 4) = '3222' 
            THEN 'Técnico ou Auxiliar de Enfermagem'
            WHEN substr(CBO, 1, 4) = '2232' 
            THEN 'Cirurgião Dentista'
            WHEN CBO = '515105' 
            THEN 'Agente Comunitário de Saúde'
        END AS categoria,
        substr(COMPETEN, 1, 4) AS ANO,
        CAST(PF.HORAHOSP + PF.HORAOUTR + PF.HORA_AMB AS FLOAT) AS CH_TOTAL
    FROM Dados.cnes.PF
    WHERE 
        substr(PF.COMPETEN, 1, 4) > 2018 AND 
        (CBO = '515105' OR 
        substr(PF.CBO, 1, 4) = '2235' OR 
        substr(PF.CBO, 1, 4) = '2232' OR 
        PF.CBO = '322205' OR
        PF.CBO = '322210' OR
        PF.CBO = '322215' OR
        PF.CBO = '322220' OR
        PF.CBO = '322245' OR
        PF.CBO = '322230' OR
        PF.CBO = '322235' OR
        PF.CBO = '322250')) 

SELECT a.ANO, 
        a.competen,
       a.CNES, 
       b.FANTASIA,
       c.uf_sigla,
       a.CODUFMUN,
       c.municipio, 
       a.categoria,   
       SUM(CH_TOTAL) AS CH,
       SUM(CH_TOTAL)/40 AS FTE40
FROM ch_cnes_selecionados a
    LEFT JOIN Dados.cnes.CADGER b
        ON a.CNES = b.CNES
    LEFT JOIN "Open Analytics Layer".Territorial."Hierarquia completa dos municípios" c
        ON a.CODUFMUN = CAST(c.cod_municipio AS CHARACTER)
GROUP BY 
        ANO,
        competen,
        CNES, 
        fantasia,
        uf_sigla,
        CODUFMUN, 
        municipio,
        categoria
```

```{r}

# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_equipe_cnes"'

equipe_saude <- sqlQuery(channel, 
                         query,
                         as.is = TRUE)


```

A seguir são filtrados apenas as equipes dos estabelecimentos presentes na base de dados.

```{r}

equipe_saude2 <- 
    equipe_saude |> 
    select(CNES, COMPETEN, categoria, FTE40) |> 
    mutate(categoria = 
             case_when(
               categoria == 
                 "Técnico ou Auxiliar de Enfermagem" ~ 
                 "tec_aux_enf",
               categoria == 
                 "Cirurgião Dentista" ~ "dentista",
               categoria == "Agente Comunitário de Saúde" ~
                 "agente_saude",
               categoria == "Enfermeiro" ~ "enfermeiro",
               TRUE ~ NA)) |> 
    mutate(FTE40 = ifelse(is.na(FTE40), 0, FTE40))
  
equipe_saude3 <- 
    equipe_saude2 |> 
    filter(CNES %in% temp3$cnes) |> 
    group_by(CNES, COMPETEN, categoria) |> 
    summarise(FTE40 = mean(FTE40)) |> 
    ungroup() |> 
    pivot_wider(names_from = categoria, 
                values_from = FTE40) |> 
    mutate(across(2:5, ~ ifelse(is.na(.), 0, .))) |> 
  mutate(COMPETEN = as.Date(paste0(COMPETEN, "01"), 
          format = "%Y%m%d"))

```

Juntando a base.

```{r}

data_cnes <- 
  temp3 |> 
    left_join(equipe_saude3, by = c("cnes"="CNES", "competen" = "COMPETEN")) |> 
  group_by(cpf_prof) |> 
  summarise(m_agente_saude = 
              mean(agente_saude),
            m_tec_aux_enf = 
              mean(tec_aux_enf),
            m_enfermeiro = 
              mean(enfermeiro),
            m_dentista = 
              mean(dentista))

base_atributos <- base_atributos |> 
  left_join(data_cnes, by = c("cpf_prof" = "cpf_prof"))
```

A seguir, iremos analisar os **agentes de saúde**.

```{r}

mean(base_atributos$m_agente_saude, na.rm = TRUE)
```

A média de agentes comunitários de saúde nos estabelecimentos que receberam médicos do programa é de 8,5. Ao desagregar por churn, observamos uma mediana maior entre os que permaneceram.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = m_agente_saude,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Número de agentes") +
  ylab("Agentes Comunitários de Saúde")

b <- base_atributos |>
  ggplot(aes(x= m_agente_saude)) + 
  geom_histogram() +
  xlab("Agentes Comunitários de Saúde") +
  ylab("Frequência")

a + b
```

Em termos de média, têm-se que o número de agentes é maior nos estabelecimentos em que os profissionais permaneceram.

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(m_agente_saude, 
                               na.rm = TRUE),2),
            mediana = round(median(m_agente_saude, 
                                   na.rm = TRUE),2),
            sd = round(sd(m_agente_saude, 
                          na.rm = TRUE),2)) |> 
  DT::datatable()

shapiro.test(base_atributos$m_agente_saude)

wilcox_test(m_agente_saude ~ churn, 
            data = base_atributos, 
            alternative = "two.sided")
```

A seguir, os **técnicos e auxiliares de enfermagem**.

```{r}
mean(base_atributos$m_tec_aux_enf, na.rm = TRUE)
```

A média de técnicos e auxiliares de enfermagem nos estabelecimentos é de 3. Ao desagregar por churn, pelo boxplot abaixo, é possível observar uma mediana maior entre os que permanecem.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = m_tec_aux_enf,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Número de ") +
  ylab("Técnicos e auxiliares de enfermagem")

b <- base_atributos |>
  ggplot(aes(x= m_tec_aux_enf)) + 
  geom_histogram() +
  xlab("Técnicos e auxiliares de enfermagem") +
  ylab("Frequência")

a + b
```

Em termos de média, os que permaneceram atuavam em estabelecimentos com uma média de técnicos e auxiliares de enfermagem maior em relação aos que migraram.

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(m_tec_aux_enf, 
                               na.rm = TRUE),2),
            mediana = round(median(m_tec_aux_enf, 
                                   na.rm = TRUE),2),
            sd = round(sd(m_tec_aux_enf, 
                          na.rm = TRUE),2)) |> 
  DT::datatable()

shapiro.test(base_atributos$m_tec_aux_enf)

wilcox_test(m_tec_aux_enf ~ churn, 
            data = base_atributos, 
            alternative = "two.sided")
```

A seguir, os **enfermeiros**.

```{r}

mean(base_atributos$m_enfermeiro, 
     na.rm = TRUE)

```

A média de enfermeiros nos estabelecimentos é de 1,8. Ao desagregar por churn não é possível observar uma mediana maior de enfermeiros nos estabelecimentos de médicos que permaneceram.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = m_enfermeiro,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Número de enfermeiros") +
  ylab("Enfermeiros")

b <- base_atributos |>
  ggplot(aes(x= m_enfermeiro)) + 
  geom_histogram() +
  xlab("Enfermeiros") +
  ylab("Frequência")

a + b
```

Em termos de média, os estabelecimentos em que os profissionais permanecem tem uma média maior de enfermeiros em relação aos que migram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(m_enfermeiro, 
                               na.rm = TRUE),2),
            mediana = round(median(m_enfermeiro, 
                                   na.rm = TRUE),2),
            sd = round(sd(m_enfermeiro, 
                          na.rm = TRUE),2)) |> 
  DT::datatable()

shapiro.test(base_atributos$m_enfermeiro)

wilcox_test(m_enfermeiro ~ churn, 
            data = base_atributos, 
            alternative = "two.sided")
```

A seguir, os **dentistas**.

```{r}
mean(base_atributos$m_dentista, 
     na.rm = TRUE)
```

A média é de 1,3 dentistas nos estabelecimentos que receberam médicos do programa. Ao desagregar por churn no boxplot abaixo é possível observar uma mediana maior entre os que permanecem.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = m_dentista,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Número de dentistas") +
  ylab("Cirurgiões-dentistas")

b <- base_atributos |>
  ggplot(aes(x= m_dentista)) + 
  geom_histogram() +
  xlab("Cirurgiões-dentista") +
  ylab("Frequência")

a + b
```

E em termos de média, o número de dentistas é maior entre os que permaneceram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(m_dentista, 
                               na.rm = TRUE),2),
            mediana = round(median(m_dentista, 
                                   na.rm = TRUE),2),
            sd = round(sd(m_dentista, 
                          na.rm = TRUE),2)) |> 
  DT::datatable()

shapiro.test(base_atributos$m_dentista)

wilcox_test(m_dentista ~ churn, data = base_atributos, alternative = "two.sided")
```

## 1.4. Atributos a nível município

Nessa seção serão agregadas as variáveis a nível municipal a partir de diveras fontes. Essas variáveis são agrupadas de acordo sobre os aspectos econômicos, de saúde, segurança pública, educação e infraestrutura.

Mas antes de prosseguirmos, iremos analisar como ocorreu a distribuição dos médicos pelo território brasileiro, primeiro por região e depois por unidade federativa.

Abaixo por **região**.

```{r}

base_atributos <- base_atributos |>  
  mutate(regiao_destino = case_when(
    (uf_destino %in% c("AM", "AP", "TO", "AC", "RR", "RO", "PA")) ~ "Norte",
    (uf_destino %in% c("BA", "AL", "RN", "SE", "PI", "PB", "CE", "MA", "PE")) ~ "Nordeste",
    (uf_destino %in% c("GO", "MT", "MS", "DF")) ~ "Centro-oeste",
    (uf_destino %in% c("SC", "RS", "PR")) ~ "Sul",
    (uf_destino %in% c("SP", "RJ", "ES", "MG")) ~ "Sudeste",
    TRUE ~ "Outro"))



base_atributos |> 
  count(regiao_destino) |> 
  mutate(percentual = n / sum(n)) |> 
  ggplot(aes(x = reorder(regiao_destino, n), 
             y = n)) +
  geom_col() + 
  coord_flip() + 
  theme_minimal() + 
  xlab("Região") + 
  ylab("Número de médicos") +
  geom_text(aes(label = sprintf("%d (%.1f%%)", n, percentual * 100)),
            position = position_stack(vjust = 0.5), 
            color = "white")
```

Observe que o Nordeste foi a região que mais recebeu médicos do programa, no entanto apresentou o menor percentual de retenção dos municípios conforme pode ser visto na tabela abaixo.

```{r}
base_atributos |> 
  group_by(regiao_destino, churn) |> 
  count() |> 
  spread(key = churn, value = n) |> 
  mutate(retencao = round(permanece/(permanece + migrou)*100,2)) |> 
  arrange(desc(retencao)) |> 
  DT::datatable()
```

Abaixo, a distribuição por **unidade federativa**.

```{r}


distribuicao_uf <- base_atributos |> 
  group_by(uf_destino) |> 
  count()

#Leitura dos dados espaciais
estados_br <- read_state(year = 2020, showProgress = FALSE)


distribuicao_uf_sf <- distribuicao_uf |> 
  left_join(estados_br, by = c("uf_destino" = "abbrev_state")) |> 
  st_as_sf()

ggplot(data = distribuicao_uf_sf) +
  geom_sf(aes(fill = n), color = NA) +  # Preenche os estados com a variável 'n'
  scale_fill_gradientn(colors = c("#e0f7fa", "#00796b"),  # Paleta de azul monocromática
                       values = rescale(c(0, 50, 100)), 
                       limits = c(0, max(distribuicao_uf_sf$n))) +  # Rescale e limita a cor com base nos dados
  labs(fill = "Número de médicos") +  # Título da legenda
  theme_void() +  # Remove eixos e grid
  geom_text(data = distribuicao_uf_sf %>% st_centroid(),  # Calcula os centróides para as etiquetas
            aes(x = st_coordinates(geom)[,1],  # Coordenada X
                y = st_coordinates(geom)[,2],  # Coordenada Y
                label = paste(n, "(", uf_destino, ")")),  # Concatenate the value of 'n' with the UF sigla
            color = "black", size = 3)  # Adiciona as etiquetas



```

Ceará foi a unidade federativa que mais recebeu médicos do programa, no entanto a retenção ficou em 21º lugar as das melhores retenção conforme pode ser visto na tabela abaixo.

```{r}
base_atributos |> 
  group_by(uf_destino, churn) |> 
  count() |> 
  spread(key = churn, value = n) |> 
  mutate(retencao = round(permanece/(permanece + migrou)*100,2)) |> 
  arrange(desc(retencao)) |> 
  DT::datatable()
```

### 1.4.1 Indicadores econômicos

Abaixo, conforme estrutura mencionada, as variáveis que indicam nível de atividade econômica.

#### 1.4.1.1 População e porte

A partir de dados do Censo 2022 do IBGE identificaremos a população dos municipios, e classificaremos por porte de acordo com a população.

O porte dos município, conforme o IBGE, é classificado de acordo com sua população:

**Pequeno Porte I**: Até 20.000 habitantes.\
**Pequeno Porte II**: Entre 20.000 e 50.000 habitantes.\
**Médio Porte**: Entre 50.000 e 100.000 habitantes.\
**Grande Porte**: Entre 100.000 e 900.000 habitantes.\
**Metrópole**: Mais de 900.000 habitantes.

Observa-se que a maioria dos médicos foi alocada em cidades de até 50 mil habitantes, visto que PP I e PP II representam aproximadamente 64% dos destinos.

```{r}
#Carregando a base de contigente populacional

pop_mun <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/pop_municipios.xlsx") |> 
  mutate(cod_mun = substr(cod_mun, 1, 6)) |> 
  mutate(populacao = as.numeric(populacao)) 

base_atributos$ibge_aloc <- as.character(base_atributos$ibge_aloc)

base_atributos <- base_atributos |> 
  left_join(pop_mun, by = c("ibge_aloc" = "cod_mun")) |> 
  select(-mun) |> 
  mutate(porte = 
           case_when((populacao < 20000) ~ "PP-I",
                     (populacao >= 20000 & 
                      populacao < 50000) ~ "PP-II",
                     (populacao >= 50000 & 
                      populacao < 100000) ~ "MP",
                     (populacao >= 100000 & 
                      populacao < 900000) ~ "GP",
                     (populacao >= 900000) ~ "Metrópole",
                      TRUE ~ "Outros casos"))

base_atributos |> 
  group_by(porte) |> 
  count() |> 
  summarise(quantidade = n) |> 
  mutate(percentual = round(quantidade/sum(quantidade)*100,2)) |> 
  arrange(desc(percentual)) |> 
  DT::datatable()

```

No entanto, a permanência dos profissionais é maior nas cidades com mais de 100 mil habitantes, conforme pode ser visto abaixo.

```{r}

base_atributos |> 
  group_by(churn, porte) |> 
  count() |> 
  ungroup() |> 
  ggplot(aes(x = reorder(porte, -n, sum), 
             y = n, fill = churn)) +
  geom_col(position = "fill") + 
  coord_flip() + 
  theme_minimal() + 
  xlab("Tipo de município") + 
  ylab("%")
```

-   Observa-se que o município com a maior população é São Gonçalo do Rio de Janeiro com 896.744 habitantes, e que recebeu 3 médicos do programa.

```{r}
base_atributos |> 
  filter(populacao == max(populacao)) |> 
  select(cns, uf_destino, 
         municipio_destino, 
         populacao, 
         porte, 
         churn) |> 
  DT::datatable()
```

-   Observa-se que o município com a menor população é Nova Aliança do Ivai do Paraná com 1.323 habitantes, e que recebeu apenas um médico do programa.

```{r}
base_atributos |> 
  filter(populacao == min(populacao)) |> 
  select(cns, 
         uf_destino, 
         municipio_destino, 
         populacao, 
         porte, 
         churn) |> 
  DT::datatable()
```

#### 1.4.1.2 PIB per capita

O próximo atributo a nível município é o PIB per capita da localidade. Para isso foram acessados dados do IBGE.

``` sql
SELECT codigo_municipio, 
       ano, 
       produto_interno_bruto_capital_precos_correntes_1 AS pib_percapita
       
FROM Dados.pib."pib_2010_2021.parquet"
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_pibpercapita"'



pib_percapita <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

Esta seção acessa os dados do PIB per capita do ano de 2019 como referência.

```{r}

pib_percapita1 <- pib_percapita |> 
  mutate(pib_percapita = as.numeric(pib_percapita)) |> 
  mutate(codigo_municipio = substring(codigo_municipio,1,6)) |> 
  filter(ano == "2019") |> 
  select(-ano)

base_atributos <- base_atributos |> 
  left_join(pib_percapita1, by = c("ibge_aloc" = "codigo_municipio"))

base_atributos |> 
  distinct(ibge_aloc, pib_percapita) |> 
  summarise(média = mean(pib_percapita))
```

A média do PIB per capita dos municípios é de R\$ 17.898,23. Ao desagregar por churn, é possível observar uma mediana maior entre os que permanecem.

```{r}
c <- base_atributos |> 
  ggplot(aes(x = pib_percapita,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Reais (R$)") +
  ylab("PIB per capita") +
  scale_x_continuous(labels = scales::label_comma())

d <- base_atributos |>
  distinct(ibge_aloc, pib_percapita) |> 
  ggplot(aes(x= pib_percapita)) + 
  geom_histogram() +
  xlab("PIB per capita") +
  ylab("Frequência") +
  scale_x_continuous(labels = scales::label_comma())

c + d
```

Em termos de média, assim como na mediana, é maior entre os que permaneceram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(média = mean(pib_percapita),
            mediana = median(pib_percapita),
            sd = sd(pib_percapita))
```

-   Abaixo é possível identificar o município com o maior PIB per capita que é de R\$ 353.505,22 com uma população de 8.142 habitantes.

```{r}
base_atributos |> 
  filter(pib_percapita == max(pib_percapita)) |> 
  select(cns, uf_destino, 
         municipio_destino, 
         populacao, 
         pib_percapita, 
         churn) |> 
  DT::datatable()
```

-   Abaixo é possível identificar o município com o menor PIB per capita que é de R\$ 4.575,16 com uma população de 17.432 habitantes.

```{r}
base_atributos |> 
  filter(pib_percapita == min(pib_percapita)) |> 
  select(cns, uf_destino, 
         municipio_destino, 
         populacao, 
         pib_percapita, 
         churn) |> 
  DT::datatable()
```

#### 1.4.1.2.1 Variação de PIB per capita entre anos

O código abaixo é usado para verificar a variação do PIB per capita entre os anos de 2010 e 2019.

```{r}
var_pib <- 
  pib_percapita |> 
  filter(ano == '2019' | ano == '2010') |> 
  spread(key = ano, value = pib_percapita) |> 
  rename(ppc_2010 = `2010`, ppc_2019 = `2019`) |> 
  mutate(variacao_pib = round((ppc_2019 * 100 / ppc_2010) - 100),2) |> 
  mutate(codigo_municipio = substr(codigo_municipio, 1, 6))

base_atributos <- base_atributos |> 
  left_join(var_pib, by = c("ibge_aloc" = "codigo_municipio")) |> 
  select(-ppc_2010, -ppc_2019)

base_atributos |> 
  distinct(ibge_aloc, variacao_pib) |> 
  summarise(média = mean(variacao_pib))
```

Entre 2010 e 2018 o PIB per capita dos municípios que receberam médicos cresceram em média 109%. Ao desagregar por churn no boxplot abaixo, não é possível ver uma diferença clara entre os que migraram e permaneceram.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = variacao_pib,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  xlab("Percentual") +
  ylab("Variação PIB per capita") +
  theme(axis.text.x = element_blank())

b <- base_atributos |>  
  distinct(ibge_aloc, variacao_pib) |> 
  ggplot(aes(x = variacao_pib)) +   
  geom_histogram() +    
  xlab("Variação PIB per capita") +   
  ylab("Frequência")  

a + b
```

Em termos de média, a diferença também não é muito expressiva.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(média = round(mean(variacao_pib),2),
            mediana = round(median(variacao_pib),2),
            sd = round(sd(variacao_pib),2)) |> 
  DT::datatable()

  
```

-   O município que apresentou o maior crescimento do PIB per capita no período analisado foi Goiana (não é Goiânia) em Pernambuco e que recebeu 4 médicos do programa.

```{r}
base_atributos |> 
  filter(variacao_pib == max(variacao_pib)) |> 
  select(cns, uf_destino, municipio_destino, 
         populacao, pib_percapita, variacao_pib, 
         churn) |> 
  DT::datatable()
```

-   O município que apresentou a pior variação do PIB per capita foi Rosário do Catete em Sergipe e que recebeu dois médicos do programa.

```{r}
base_atributos |> 
  filter(variacao_pib == min(variacao_pib)) |> 
  select(cns, uf_destino, municipio_destino, 
         populacao, pib_percapita, variacao_pib, 
         churn) |> 
  DT::datatable()
```

#### 1.4.1.3 População ocupada

Os dados da população ocupada foram coletados da Estatísticas do Cadastro Central de Empresas (CEMPRE) de 2019 do IBGE por meio do SIDRA, tabela 1685.

E calculamos o percentual da população ocupada com os dados do Censo 2022.

```{r}

pop_ocupada_mun <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/pop_ocupada_mun.xlsx") |> 
  select(-municipio) |> 
  mutate(across(-cod_ibge, 
                as.numeric)) |>  # Converte todas as colunas, exceto cod_ibge, para "character"
  pivot_longer(
    cols = -cod_ibge,
    names_to = "ano",
    values_to = "pop_ocupada"
  ) |> 
  filter(ano == "2019") |> 
  mutate(cod_ibge = substring(cod_ibge,1,6)) |> 
  select(-ano)

base_atributos <- 
  base_atributos |> 
  left_join(pop_ocupada_mun, 
            by = c("ibge_aloc" = "cod_ibge")) |> 
  mutate(tx_pop_ocupada_2019 = (pop_ocupada/populacao)*100) |> 
  rename(pop_ocupada_2019 = pop_ocupada)

base_atributos |> 
  distinct(ibge_aloc, tx_pop_ocupada_2019) |> 
  summarise(média = mean(tx_pop_ocupada_2019))
```

A média das taxas de ocupação dos municípios é de 11,7%, sendo que ela é maior nos municípios em que os médicos permanecem conforme boxplot abaixo.

```{r}
e <- base_atributos |> 
  ggplot(aes(x = tx_pop_ocupada_2019,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  xlab("Percentual") +
  ylab("Taxa de ocupação") +
  theme(axis.text.x = element_blank())

f <- base_atributos |>  
  distinct(ibge_aloc, tx_pop_ocupada_2019) |> 
  ggplot(aes(x = tx_pop_ocupada_2019)) +   
  geom_histogram() +    
  xlab("Taxa de ocupação") +   
  ylab("Frequência")  

e + f
```

Abaixo pode-se olhar a diferença em termos de média.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(tx_pop_ocupada_2019)*100,2),
            mediana = round(median(tx_pop_ocupada_2019)*100,2),
            sd = round(sd(tx_pop_ocupada_2019)*100,2)) |> 
  DT::datatable()
```

-   O município com a maior taxa de ocupação é Sapezal do Mato Grosso com 37,78%.

```{r}
base_atributos |> 
  filter(tx_pop_ocupada_2019 == max(tx_pop_ocupada_2019)) |> 
  select(cns, uf_destino, municipio_destino, 
         populacao, pib_percapita, tx_pop_ocupada_2019, 
         churn) |> 
  DT::datatable()
```

-   O município com a menor taxa de ocupação é Ipixuna do Amazonas com 1,41%.

```{r}
base_atributos |> 
  filter(tx_pop_ocupada_2019 == min(tx_pop_ocupada_2019)) |> 
  select(cns, uf_destino, municipio_destino, 
         populacao, pib_percapita, tx_pop_ocupada_2019, 
         churn) |> 
  DT::datatable()
```

### 1.4.2 Indicadores de saúde

A seguir, as variáveis relacionadas a qualidade e acesso à saúde.

#### 1.4.2.2 Número vagas de medicina

A seguir, adicionaremos a variável número de vagas de medicina por município a partir de dados do INEP, e calcularemos o número de vagas por mil habitantes.

``` sql
SELECT cod_ibge, SUM(vagas) AS vagas_medicina 

FROM "Open Analytics Layer"."Educação"."Quantidade de vagas, matriculados, concluintes e inscritos em curso superior por município"

WHERE curso = 'Medicina' and ano = 2019

GROUP BY(cod_ibge)
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_vagas_medicina"'



vagas_medicina <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

```{r}

base_atributos <- 
  base_atributos |> 
  left_join(vagas_medicina, 
            by = c("ibge_aloc" = "cod_ibge")) |> 
  mutate(vagas_medicina = as.numeric(vagas_medicina)) |> 
  mutate(vagas_medicina_milhab = (vagas_medicina/populacao)*1000) |> 
  mutate(vagas_medicina = 
           ifelse(is.na(vagas_medicina), 0, 
                  vagas_medicina)) |> 
  mutate(vagas_medicina_milhab = 
           ifelse(is.na(vagas_medicina_milhab), 0, 
                  vagas_medicina_milhab)) |> 
  select(-vagas_medicina)

base_atributos |> 
  distinct(ibge_aloc, vagas_medicina_milhab) |> 
  summarise(média = mean(vagas_medicina_milhab))

```

A média de vagas de medicina por mil habitantes é de aproximadamente 0,04 e visualmente pelo boxplot abaixo não é possível observar diferença desagregada por churn, entende-se apenas que a maioria dos municípios não tem vagas em cursos de medicina.

```{r}
h <- base_atributos |> 
  ggplot(aes(x = vagas_medicina_milhab,
             fill = churn)) +
  geom_boxplot() +
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  ylab("Vagas de medicina por mil hab.") +
  xlab("Número de vagas")

i <- base_atributos |> 
  ggplot(aes(x = vagas_medicina_milhab)) +
  geom_histogram()

h + i
```

Apenas abaixo conseguimos identificar uma diferença: as cidades onde os médicos permaneceram tiveram, em média, mais vagas de medicina em comparação às cidades de onde migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(vagas_medicina_milhab),2),
            mediana = round(median(vagas_medicina_milhab),2),
            sd = round(sd(vagas_medicina_milhab),2)) |> 
  DT::datatable()
```

-   A cidade com maior número de vagas de medicina foi Goiatuba da Goiás com 3,75 por mil habitantes.

```{r}
base_atributos |> 
  filter(vagas_medicina_milhab == max(vagas_medicina_milhab)) |> 
  select(cns, uf_destino, 
         municipio_destino, populacao, 
         pib_percapita, vagas_medicina_milhab, churn) |> 
  DT::datatable()
```

#### 1.4.2.3 Orçamento per capita para a saúde

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o DataSUS de 2019. E o cálculo realizado é: Gasto total em saúde ÷ População total do município.

```{r}
orcamento_saude <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, orcamento_saude) |> 
  mutate(id = substr(id, 1, 6))


base_atributos <- base_atributos |> 
  left_join(orcamento_saude, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, orcamento_saude) |> 
  summarise(média = mean(orcamento_saude))
```

A média de orçamento de saúde dos municípios é de R\$ 695,63 e conforme boxplot abaixo não é possível identificar diferença desagregada por churn.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = orcamento_saude,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Reais (R$)") +
  ylab("Orçamento de saúde")

b <- base_atributos |> 
  ggplot(aes(x= orcamento_saude)) + 
  geom_histogram() +
  xlab("Orçamento de saúde") +
  ylab("Frequência")

a + b 
```

Em termos de média, a diferença do orçamento per capita é pequena, sendo maior no caso dos municípios de indivíduos que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(orcamento_saude),2),
            mediana = round(median(orcamento_saude),2),
            sd = round(sd(orcamento_saude),2)) |> 
  DT::datatable()
```

-   O município com o maior orçamento de saúde per capita é Santa Margarida do Sul do Rio Grande do Sul com R\$ 5.561,87.

```{r}
base_atributos |> 
  filter(orcamento_saude == max(orcamento_saude)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, orcamento_saude, churn) |> 
  DT::datatable()
```

-   O município com o menor orçamento de saúde per capita é Igarape-ACU do Pará com RS 202,40.

```{r}
base_atributos |> 
  filter(orcamento_saude == min(orcamento_saude)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, orcamento_saude, churn) |> 
  DT::datatable()
```

#### 1.4.2.4 População atendida com esgotamento sanitário

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o SNIS do ano de 2020. O método de cálculo é: População total atendida com esgotamento sanitário ÷ População total do município (x100).

```{r}
esgoto_sanitario <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, esgotamento_sanitario) |> 
  mutate(id = substr(id, 1, 6))
  
base_atributos <- base_atributos |> 
  left_join(esgoto_sanitario, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, esgotamento_sanitario) |> 
  summarise(média = mean(esgotamento_sanitario))
```

A média da cobertura com esgoto sanitário dos municípios é de 21% e quando desagregado por churn é maior entre os que tiveram indivíduos que permaneceram.

```{r}

a <- base_atributos |> 
  ggplot(aes(x = esgotamento_sanitario,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Percentual") +
  ylab("Esgotamento sanitário")

b <- base_atributos |> 
  ggplot(aes(x= esgotamento_sanitario)) + 
  geom_histogram() +
  xlab("Esgotamento sanitário") +
  ylab("Frequência")

a + b
```

Abaixo é possível observar que a média de cobertura de esgoto sanitário é ligeiramente maior entre os que permaneceram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(esgotamento_sanitario),2),
            mediana = round(median(esgotamento_sanitario),2),
            sd = round(sd(esgotamento_sanitario),2)) |> 
  DT::datatable()
```

### 1.4.3 Indicadores de segurança pública

#### 1.4.3.1 Taxa de homicídio

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o DataSUS de 2019. O método de cálculo é: Número total de mortes por homicídio ÷ População total (x100.000).

```{r}
tx_homicidio <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, taxa_homicidio) |> 
  mutate(id = substr(id, 1, 6))

base_atributos <- base_atributos |> 
  left_join(tx_homicidio, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, taxa_homicidio) |> 
  summarise(Média = mean(taxa_homicidio))
```

A média da taxa de homicídio dos municípios que receberam médicos do programa é de 25,6 a cada 100 mil habitantes. Na desagregação por churn no boxplot abaixo, a mediana dos municípios de indivíduos que permaneceram é ligeiramente maior.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = taxa_homicidio,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Mortes por mil habitantes") +
  ylab("Taxa de homicídio")

b <- base_atributos |>
  distinct(ibge_aloc, taxa_homicidio) |> 
  ggplot(aes(x= taxa_homicidio)) + 
  geom_histogram() +
  xlab("Taxa de homicídio") +
  ylab("Frequência")

a + b
```

Assim como a mediana demonstrada pelo boxplot, a média das cidades de médicos que permaneceram também é ligeiramente maior em relação das que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(taxa_homicidio),2),
            mediana = round(median(taxa_homicidio),2),
            sd = round(sd(taxa_homicidio),2)) |> 
  DT::datatable()
```

-   O município com maior índice de homicídio é Jussari da Bahia e que recebeu dois médicos do programa.

```{r}
base_atributos |> 
  filter(taxa_homicidio == max(taxa_homicidio)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, taxa_homicidio, churn) |> 
  DT::datatable()
```

### 1.4.4 Indicadores de educação

#### 1.4.4.1 IDEB anos iniciais

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o MEC / IDEB de 2019. Método: Nota do Índice de Desenvolvimento da Educação Básica (IDEB) - Rede municipal - Anos Iniciais.

```{r}
ideb_inicio <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, ideb_anosiniciais) |> 
  mutate(id = substr(id, 1, 6))

base_atributos <- base_atributos |> 
  left_join(ideb_inicio, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, ideb_anosiniciais) |> 
  summarise(média = mean(ideb_anosiniciais, na.rm = TRUE))
```

A média dos municípios que receberam médicos do programa é de 5,36. E quando desagregado por churn a mediana dos municípios com médicos que migraram é maior em comparação aos do que permaneceram conforme boxplot abaixo.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = ideb_anosiniciais,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Nota IDEB") +
  ylab("Nota IDEB - Anos Iniciais")

b <- base_atributos |>
  distinct(ibge_aloc, ideb_anosiniciais) |> 
  ggplot(aes(x= ideb_anosiniciais)) + 
  geom_histogram() +
  xlab("Nota IDEB - Anos Iniciais") +
  ylab("Frequência")

a + b
```

Assim como na mediana, a média também indica diferença.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(ideb_anosiniciais, na.rm = TRUE), 2),
            mediana = round(median(ideb_anosiniciais, na.rm = TRUE), 2),
            sd = round(sd(ideb_anosiniciais, na.rm = TRUE), 2)) |> 
  DT::datatable()
```

-   O município com a maior nota IDEB dos anos iniciais é Mucambo no Ceará.

```{r}
base_atributos |> 
  filter(ideb_anosiniciais == max(ideb_anosiniciais, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, ideb_anosiniciais, churn) |> 
  DT::datatable()
```

-   O município com a menor nota IDEB dos anos iniciais é Pedrinhas em Sergipe.

```{r}
base_atributos |> 
  filter(ideb_anosiniciais == min(ideb_anosiniciais, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, ideb_anosiniciais, churn) |> 
  DT::datatable()
```

#### 1.4.4.1 IDEB anos finais

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o MEC / IDEB de 2019. Método: Nota do Índice de Desenvolvimento da Educação Básica (IDEB) - Rede municipal - Anos Iniciais.

```{r}
ideb_final <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, ideb_anosfinais) |> 
  mutate(id = substr(id, 1, 6))

base_atributos <- base_atributos |> 
  left_join(ideb_final, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, ideb_anosfinais) |> 
  summarise(média = mean(ideb_anosfinais, na.rm = TRUE))
```

A média da nota ideb dos anos finais é de 4,28, e assim como na nota dos anos inicias, a nota maior nos municípios com médicos que migraram conforme boxplot.

```{r}

a <- base_atributos |> 
  ggplot(aes(x = ideb_anosfinais,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Nota IDEB - Anos Finais") +
  ylab("Nota IDEB")

b <- base_atributos |>
  distinct(ibge_aloc, ideb_anosfinais) |> 
  ggplot(aes(x= ideb_anosfinais)) + 
  geom_histogram() +
  xlab("Nota IDEB - Anos Finais") +
  ylab("Frequência")

a + b
```

Em termos de média, a diferença é decimal.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(ideb_anosfinais, na.rm = TRUE),2),
            mediana = round(median(ideb_anosfinais, na.rm = TRUE),2),
            sd = round(sd(ideb_anosfinais, na.rm = TRUE),2)) |> 
  DT::datatable()
```

-   O município com a maior nota Ideb dos anos finais é Pires Ferreira no Ceará.

```{r}
base_atributos |> 
  filter(ideb_anosfinais == max(ideb_anosfinais, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, ideb_anosfinais, churn) |> 
  DT::datatable()
```

-   O município com a menor nota Ideb dos anos finais é Pedro Osório no Rio Grande do Sul.

```{r}
base_atributos |> 
  filter(ideb_anosfinais == min(ideb_anosfinais, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, ideb_anosfinais, churn) |> 
  DT::datatable()
```

### 1.4.5 Indicadores de infraestrutura

#### 1.4.5.1 Investimento público em infraestrutura urbana por habitante

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o SICONFI e IBGE PIB MUNICIPAL de 2019. Método: Valor do investimento público em infraestrutura ÷ Número de habitantes.

```{r}

infraestrutura <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, investimento_infraestrutura) |> 
  mutate(id = substr(id, 1, 6))

base_atributos <- base_atributos |> 
  left_join(infraestrutura, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, investimento_infraestrutura) |> 
  summarise(média = mean(investimento_infraestrutura))
```

A média per capita do investimento em infraestrutura dos municípios é de R\$ 3.310,47. Ao desagregar por churn, é possível observar uma mediana maior nas cidades de médicos que migraram.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = investimento_infraestrutura,
             fill = churn)) +
  geom_boxplot() +
  coord_flip() +
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "top") +
  ylab("Investimento em infraestrutura per capita") +
  xlab("Investimento per capita (R$)")

b <- base_atributos |> 
  ggplot(aes(x = investimento_infraestrutura)) +
  geom_histogram() +
  ylab("Frequência") +
  xlab("Investimento em infraestrutura per capita")

a + b
```

Assim como na mediana, a média é maior entre os que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(investimento_infraestrutura),2),
            mediana = round(median(investimento_infraestrutura),2),
            sd = round(sd(investimento_infraestrutura),2)) |> 
  DT::datatable()
```

-   O municípios com o maior investimento per capita em infraestrutura é Itanagra da Bahia.

```{r}
base_atributos |> 
  filter(investimento_infraestrutura == max(investimento_infraestrutura, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, investimento_infraestrutura, churn) |> 
  DT::datatable()
```

#### 1.4.5.2 Equipamentos esportivos municipais

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é a MUNIC de 2018. Método: Número total de equipamentos esportivos públicos ÷ População total do município (x100.000).

```{r}
equip_esportivos <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, equipamentos_esportivos) |> 
  mutate(id = substr(id, 1, 6))

base_atributos <- base_atributos |> 
  left_join(equip_esportivos, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, equipamentos_esportivos) |> 
  summarise(média = mean(equipamentos_esportivos))
```

A média de equipamentos esportivos por 100 mil habitantes é de 11,9. Ao desagregar por churn, é possível identificar que a mediana é maior entre os que migraram conforme boxplot abaixo.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = equipamentos_esportivos,
             fill = churn)) +
  geom_boxplot() +
  coord_flip() +
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "top") +
  xlab("Equipamentos por 100 mil habitantes") +
  ylab("Equipamentos esportivos")

b <- base_atributos |> 
  ggplot(aes(x = equipamentos_esportivos)) +
  geom_histogram() +
  ylab("Frequência") +
  xlab("Equipamentos por 100 mil habitantes")

a + b
```

Em termos de média, assim como na mediana, é maior entre os que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(equipamentos_esportivos),2),
            mediana = round(median(equipamentos_esportivos),2),
            sd = round(sd(equipamentos_esportivos),2)) |> 
  DT::datatable()
```

-   O município com o maior número de equipamentos esportivos por 100 mil habitantes é Conceição de Ipanema em Minas Gerais.

```{r}
base_atributos |> 
  filter(equipamentos_esportivos == max(equipamentos_esportivos, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, equipamentos_esportivos, churn) |> 
  DT::datatable()
```

#### 1.4.5.3 Centros Culturais, casas e espaços de cultura

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades -- Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é a MUNIC de 2019. Método: Número de centros culturais, espaços e casas de cultura públicos e privados ÷ População total do município (x100.000).

```{r}
equip_culturais <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, equipamentos_culturais) |> 
  mutate(id = substr(id, 1, 6))

base_atributos <- base_atributos |> 
  left_join(equip_culturais, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

base_atributos |> 
  distinct(ibge_aloc, equipamentos_culturais) |> 
  summarise(média = mean(equipamentos_culturais))
```

A média de equipamentos culturais por 100 mil habitantes é de 13,4. Ao desagregar por churn, a mediana é maior entre os que migraram conforme boxplot abaixo.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = equipamentos_culturais,
             fill = churn)) +
  geom_boxplot() +
  coord_flip() +
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "top") +
  xlab("Equipamentos por 100 mil habitantes") +
  ylab("Equipamentos esportivos")

b <- base_atributos |> 
  distinct(ibge_aloc, equipamentos_culturais) |> 
  ggplot(aes(x = equipamentos_culturais)) +
  geom_histogram() +
  ylab("Frequência") +
  xlab("Equipamentos por 100 mil habitantes")

a + b
```

Em termos de média, assim como na mediana, é maior entre os que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = round(mean(equipamentos_culturais),2),
            mediana = round(median(equipamentos_culturais),2),
            sd = round(sd(equipamentos_culturais),2)) |> 
  DT::datatable()
```

-   O município com o maior número de equipamentos culturais por 100 mil habitantes é Água Limpa em Goiás.

```{r}
base_atributos |> 
  filter(equipamentos_culturais == max(equipamentos_culturais, na.rm = TRUE)) |> 
  select(cns, uf_destino, municipio_destino, populacao, pib_percapita, equipamentos_culturais, churn) |> 
  DT::datatable()
```

#### 1.4.5.4 Distância da capital

Este dado foi coletado da plataforma Google Maps, e mostra a distância dos municípios que receberam médicos do programa até a capital da respectiva unidade federativa.

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
                    sprintf("DRIVER=Dremio Connector;
                             HOST=%s;
                             PORT=%s;
                             UID=%s;
                             PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM Dados.distancias."distancias_municipios_capitais.parquet"'


distancia_capital <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

```{r}
distancia_capital <- distancia_capital |> 
  select(cod_municipio, km) |> 
  rename(distancia_capital = km)

base_atributos <- base_atributos |> 
  left_join(distancia_capital, by = c("ibge_aloc" = "cod_municipio"))

base_atributos |> 
  distinct(distancia_capital) |> 
  summarise(média = mean(distancia_capital))
```

A média de distância dos municípios que receberam médicos em relação a sua capital é de 364 km. Ao desagregar por churn, conforme boxplot abaixo, observamos uma mediana maior nos munípios em que médicos permaneceram.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = distancia_capital,
             fill = churn)) +
  geom_boxplot() +
  coord_flip() +
  theme(axis.text.x = element_blank()) +
  theme(legend.position = "top") +
  xlab("Equipamentos por 100 mil habitantes") +
  ylab("Equipamentos esportivos")

b <- base_atributos |> 
  distinct(ibge_aloc, distancia_capital) |> 
  ggplot(aes(x = distancia_capital)) +
  geom_histogram() +
  ylab("Frequência") +
  xlab("Equipamentos por 100 mil habitantes")

a + b
```

Assim como na mediana, a média é maior entre os que permaneceram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(media = 
              round(mean(distancia_capital),2),
            mediana = 
              round(median(distancia_capital),2),
            sd = 
              round(sd(distancia_capital),2)) |> 
  DT::datatable()
```

#### 1.4.5.5 Estabelecimentos de saúde por município

A seguir é levantado, com base na base de dados CNES-ST, o número de estabelecimentos de saúde por município. A tabela abaixo descreve o tipo de estabelecimentos agregados.

+----------------------------------+----------------+
| Tipo de estabelecimento          | Categoria      |
+==================================+:==============:+
| Hospital Geral;                  | Hospitais      |
|                                  |                |
| Hospital Especializado.          |                |
+----------------------------------+----------------+
| Pronto-socorro;                  | Pronto-socorro |
|                                  |                |
| Pronto-atendimento.              |                |
+----------------------------------+----------------+
| Clínica/Centro de Especialidade; | Clínicas       |
|                                  |                |
| Consultório Isolado.             |                |
+----------------------------------+----------------+

``` sql
WITH consulta1 AS (
SELECT  ano,
        cod_regsaud,
        regiao_saude,
        cod_ibge,
        municipio,
        descricao,
        CASE
            WHEN descricao = 'Hospital Geral' OR descricao = 'Hospital Especializado' THEN 'Hospitais'
            WHEN descricao = 'Pronto-Socorro Especializado' OR descricao = 'Pronto-Socorro Geral' THEN 'Pronto-socorro'
            WHEN descricao = 'Consultório Isolado' OR descricao = 'Clínica/Centro de Especialidade' THEN 'Clínicas'
        END descricao_recode,
        nivel_atencao,
        CAST(numero_estabelecimentos as INTEGER) as qntd
FROM "Open Analytics Layer".Infraestrutura."Razão de estabelecimentos de saúde por população"
WHERE ano IN (2019, 2020, 2021, 2022, 2023, 2024) AND descricao IN ('Pronto-Socorro Especializado', 'Pronto-Socorro Geral', 'Hospital Geral', 'Hospital Especializado', 'Consultório Isolado', 'Clínica/Centro de Especialidade')
),

consulta2 AS (
SELECT ano,
        municipio,
        cod_ibge,
        descricao_recode,
        SUM(qntd) AS qntd
FROM consulta1
    GROUP BY ano, municipio, cod_ibge, descricao_recode
)

SELECT municipio,
        cod_ibge,
        descricao_recode,
        AVG(qntd) AS qntd_estabelecimentos_medio
FROM consulta2
    GROUP BY municipio, descricao_recode, cod_ibge
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
                    sprintf("DRIVER=Dremio Connector;
                             HOST=%s;
                             PORT=%s;
                             UID=%s;
                             PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmm_estabelecimentos_municipio"'


estabelecimentos_mun <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

```{r}
estabelecimentos_mun2 <- estabelecimentos_mun |> 
  mutate(qntd_estabelecimentos_medio = round(qntd_estabelecimentos_medio, 2)) |> 
  pivot_wider(names_from = descricao_recode, 
              values_from = qntd_estabelecimentos_medio,
              names_glue = "{descricao_recode}_muni")

estabelecimentos_mun3 <- estabelecimentos_mun2 |> 
  select(-municipio) 

base_atributos <- base_atributos |> 
  left_join(estabelecimentos_mun3, by = c("ibge_aloc" = "cod_ibge")) |> 
  mutate(across(39:41, ~ if_else(is.na(.), 0, .)))
```

#### 1.4.5.5 Estabelecimentos de saúde por região de saúde

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
                    sprintf("DRIVER=Dremio Connector;
                             HOST=%s;
                             PORT=%s;
                             UID=%s;
                             PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmm_estabelecimentos_regiaosaude"'


estabelecimentos_regsaude <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

```{r}
estabelecimentos_regsaude2 <- estabelecimentos_regsaude |> 
  mutate(qntd_estabelecimentos_medio = round(qntd_estabelecimentos_medio, 2)) |> 
  pivot_wider(names_from = descricao_recode, 
              values_from = qntd_estabelecimentos_medio,
              names_glue = "{descricao_recode}_regsaud")

estabelecimentos_regsaude3 <- estabelecimentos_regsaude2 |> 
  select(-cod_regsaud, -regiao_saude) 

base_atributos <- base_atributos |> 
  left_join(estabelecimentos_regsaude3, by = c("ibge_aloc" = "cod_municipio")) |> 
  mutate(across(42:44, ~ if_else(is.na(.), 0, .)))
```

# 2. Armazenando resultados

epois de realizados todos os pontos, vamos deixar a base pronta para rodar modelos preditivos.

```{r}

base_final <- base_atributos |> 
                    select(meses_no_local_alocado,
                           churn, idade, anos_formacao,
                           atuacao_previa_no_municipio, 
                           anos_atuacao_previa_no_municipio,
                           media_vinculos_mes, Prorrogado,
                           m_agente_saude, m_tec_aux_enf,
                           m_enfermeiro, m_dentista, 
                           regiao_destino, populacao, 
                           porte, pib_percapita, 
                           variacao_pib, tx_pop_ocupada_2019,
                           orcamento_saude, esgotamento_sanitario,
                           taxa_homicidio, ideb_anosfinais, 
                           ideb_anosfinais, investimento_infraestrutura, equipamentos_esportivos,
                           equipamentos_culturais, distancia_capital,
                           Hospitais_regsaud, Hospitais_muni,
                           `Pronto-socorro_regsaud`, `Pronto-socorro_muni`,
                           Clínicas_muni, Clínicas_regsaud)

writexl::write_xlsx(base_final, "~/GitHub/sa_maismedicos/01_dados/dados resultantes/df_modelagem0303_v2.xlsx")

write.csv(base_final, "~/GitHub/sa_maismedicos/01_dados/dados resultantes/df_modelagem0303_v2.csv")

```
