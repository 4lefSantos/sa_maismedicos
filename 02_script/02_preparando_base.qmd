---
title: "sa_fluxo_migratorio"
format: html
editor: visual
---

# Churn Prediction: Programa Mais Médicos para o Brasil (PMMB)

O objetivo desse trabalho é realizar uma análise do Programa Mais Médicos para o Brasil referente ao 18º Ciclo (EDITAL Nº 11, DE 10 DE MAIO DE 2019), o programa é direcionado para atenção básica de saúde.

O programa prevê vigência de três anos e a seleção é estruturada em **duas fases**:

1ª. Destinado a formados e revalidados em instituições brasileiras.\
2ª. Destinação das vagas remanescentes para habilitados médicos no exterior (médico intercambista).

O médico indica **quatro localidades em ordem de preferência**. A concorrência se dará entre os profissionais que marcaram o maior grau de preferência, isto é, entre os que marcaram como primeira opção, na ausência, entre os segunda opção e assim sucessivamente.

Entre os **critérios de classificação** estão:

\- Título de Especialista e/ou Residência em Medicina da Família e Comunidade;\
- Atuação como médico em Equipe de Saúde da Família;\
- Ter sido bolsista do Programa de Educação pelo Trabalho para a Saúde (PET);\
- Ter participado como estagiário em alguma edição da Vivência e Estágio na Realidade - do SUS (VER-SUS).

**Em caso de empate**, impera os seguintes critérios conforme ordem a seguir:

\- Candidatos que já atuaram no Programa Mais Médicos para o Brasil;\
- Maior idade;\
- Data de formação.

No caso dos médicos intercambistas, além de auto-declarar conhecimento mínimo na lingua portuguesa, precisam ser aprovados no **Módulo de Acolhimento e Avaliação**. O módulo é executado em Brasília/DF, na modalidade presencial, com carga horária mínima de 160 horas. Contempla conteúdo relacionado à legislação referente ao SUS, notadamente da Atenção Básica em Saúde, aos protocolos clínicos de atendimento definidos pelo Ministério da Saúde, à Língua Portuguesa e ao Código de Ética Médica.

Após aprovação, o médico deverá se apresentar no período indicado, no município de alocação, perante o gestor municipal, portando 2 (duas) vias do Termo de Adesão e Compromisso.

Já em exercício, o médico deverá cumprir **carga horária de 40 horas** semanalmente, 8 horas em atividades acadêmicas teóricas e 32 horas em atividades nas unidades básicas de saúde no Município.

O edital não é taxativo em proibir outros vínculos profissionais, desde que seja compatível com a carga horária do programa. Veja:

2.2.5. Não possuir vínculo de serviço com carga horária incompatível com as exigências do Projeto\*;

\
\* Mediante declaração, que ficará registrada no Termo de Aceite, quando do preenchimento do formulário de adesão.

Abaixo os pacotes que serão necessários.

```{r}
#|warning: FALSE

library(tidyverse)
library(readxl)
library(geosphere)
library(TraMineR)
library(TraMineRextras)
library(factoextra)
library(genderBR)
library(lubridate)
library(writexl)
library(RODBC)
library(estimatr)
library(plm)
library(patchwork)

```

## 1. Montagem da base de dados.

Seguindo o objetivo do script, a elaboração da base de dados com os fatores (variáveis) relacionados aos médicos participantes do programa seguirá a seguinte estrutura:

1.1 **Tratamento preliminar**: A partir da identificação dos médicos por meio de webscraping, realiza-se a validação dos profissionais empossados com base no levantamento do histórico profissional.

1.2 **Atributos a nível individuo**: São levantadas as variáveis relacionados aos médicos de forma individualizada.

1.3 **Atributos a nível estabelecimento**: São levantadas as variáveis que caracterizam os estabelecimentos de saúde que receberam médicos do programa.

1.4 **Atributos a nível município**: São levantadas as variáveis que caracterizam os municípios que receberam médicos do programa.

Conforme estrutura mencionada, a elaboração inicia com o tratamento preliminar que é realizado logo a seguir.

## 1.1. Tratamento de dados do Mais Médicos

A primeira etapa consiste na elaboração da base de dados com tratamento do Mais Médicos.

A partir dos resultados do edital do 18º Ciclo do PMMB, identificamos os médicos e realizamos o processo de *web scrapping* para identificar o CNS desses profissionais no site CNES.

Após a transformação em planilha dos resultados do edital e a identificação do CNS pela raspagem, abriremos esses dados que representam 2452 médicos. Para alguns médicos, não foi possível identificar o número de CNS (265 médicos). Isso ocorre devido à presença de homônimos.

Para identificar o sexo, utilizamos a função `get_gender()` a partir dos nomes. No entanto, não foi possível a identificação em 144 profissionais. Isso ocorre, pois são nomes que podem ser assumidos por ambos os sexos.

Restando o número de 2043 médicos.

```{r}

cns_inscricao <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/Edital_11_2019_resultado_cns.xlsx") |> 
  select(nome, 
         uf_aloc, 
         municipio_aloc, 
         ibge_aloc,
         participou_pmmb, 
         data_nascimento,
         data_formacao, 
         fase, 
         resultado) |> 
  rename(cns = resultado) |> 
  rename(municipio_destino = municipio_aloc) |> 
  rename(uf_destino = uf_aloc) |> 
  mutate(cns = as.character(cns)) |>  
  filter(!is.na(cns))

cns_inscricao <- 
  cns_inscricao |> 
  mutate(sexo = get_gender(nome)) |> 
  filter(!is.na(sexo))

```

Com base nesse resultado final, extraímos todos os CNS em um vetor para executar uma consulta no datalake, a fim de identificar os respectivos CPFs. Cabe mencionar que estes CPFs são criptografados, mas que podem ser utilizados como chave de identificação individualizada.

Essa consulta gerou uma base denominada CNES_cns.

Filtraremos essa base a partir da competência 201901 e, em seguida, identificaremos os CPFs únicos para realizar uma nova consulta com esses CPFs, trazendo os dados completos.

``` sql
SELECT a.CNES, 
       b.uf,
       b.uf_sigla, 
       a.CODUFMUN, 
       b.municipio,
       b.latitude,
       b.longitude,
       a.CPF_PROF, 
       a.CBO, 
       a.NOMEPROF, 
       a.CNS_PROF,
       a.VINCULAC, 
       a.HORAOUTR, 
       a.HORAHOSP, 
       a.HORA_AMB, 
       a.COMPETEN
FROM Dados.cnes.PF a
    LEFT JOIN "Analytics Layer".Territorial."Municípios - Hierarquia Completa" b
        ON a.CODUFMUN = CAST(b.cod_municipio AS CHARACTER)
WHERE CNS_PROF IN (lista)
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
                    sprintf("DRIVER=Dremio Connector;
                             HOST=%s;
                             PORT=%s;
                             UID=%s;
                             PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."Consulta_maismedicos_2019_cns"'


CNES_cns <- sqlQuery(channel, query, 
                     as.is = TRUE)

```

```{r}
#identificando os CPF

lista_cpf <- 
  CNES_cns |> 
  filter(COMPETEN >= 201901) |> 
  mutate(CNS_PROF = as.character(CNS_PROF)) |> 
  select(CPF_PROF, CNS_PROF, 
         NOMEPROF) |> 
  distinct(CPF_PROF)

```

Observa-se que a lista de CPF's retornou apenas 2034 observações (nove a menos que o original). Esse número reduzido é devido a médicos duplicados em razão de registros com letras de nomes trocadas. Agora já identificada a variável CPF_PROF, executaremos a consulta abaixo para baixar os dados completos dos profissionais pelos respectivos CPF_PROF.

**Observação**: Este procedimento foi realizado, pois nem sempre o CNS é preenchido pelos estabelecimentos. Portanto, optamos por pegar o CPF criptografado, pois o grau de preenchimento possui maior completude.

``` sql
SELECT a.COMPETEN,
       a.CODUFMUN, 
       c.uf_sigla,
       c.municipio_pad,
       a.CNES, 
       b.FANTASIA,
       a.TP_UNID,
       a.CNS_PROF,
       a.CPF_PROF,
       a.NOMEPROF,
       a.PROF_SUS,
       a.vinculac,
       a.HORAHOSP,
       a.HORA_AMB,
       a.HORAOUTR
FROM Dados.cnes.PF a
    LEFT JOIN Dados.cnes.CADGER b
        ON a.CNES = b.CNES
    LEFT JOIN "Analytics Layer".Territorial."Municípios - Hierarquia Completa" c
        ON a.CODUFMUN = CAST(c.cod_municipio AS CHARACTER)
WHERE CPF_PROF IN (lista)
ORDER BY 
    COMPETEN
```

```{r}
#| message: false
#| warning: false
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(
              sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."Consulta_maismedicos_2019"'



CNES_cpf <- sqlQuery(channel, 
                     query, 
                     as.is = TRUE)
```

O próximo passo será unir as duas bases:

1\) `cns_inscricao`: obtida a partir do resultado do edital nº 18/2019, pois estas trazem dados sobre o inscrito (ex.: local onde foi alocado, ano de formação)

2\) `CNES_cpf`: base do CNES-PF com o acompanhamento destes indivíduos ao longo do tempo.

No entanto, como a base de inscrição não possui a variável CPF, primeiro será necessário adicioná-la a essa base para, em seguida, realizar um `left_join` com a base CNES_cpf.

```{r}

lista_cns_cpf <- 
        CNES_cns |> 
        filter(COMPETEN >= 201901) |> 
        mutate(CNS_PROF = as.character(CNS_PROF)) |> 
        select(CPF_PROF, CNS_PROF) |> 
        distinct(CPF_PROF, CNS_PROF)

cns_inscricao <- 
  cns_inscricao |> 
  left_join(lista_cns_cpf, 
            by = c("cns" = "CNS_PROF"))

```

Agora adicionada a coluna de CPF na base cns_inscricao, faremos um `left join` entre a base CNES_cpf e ela.

```{r}

base_tratada <- CNES_cpf |> 
                left_join(cns_inscricao, 
                  by = c("CPF_PROF" = "CPF_PROF"))

```

O próximo passo é identificar os médicos que iniciaram no programa. Esse mapeamento será realizado com o atendimento de alguns critérios:

1.  identifica se o médico está na cidade o qual foi designado em algum momento no ano de 2019;

2.  está alocado em uma unidade de atenção básica;

Esse tratamento foi especialmente importante, pois as vezes o profissional chegou a passar no programa, mas não assumiu.

Com essa variável verificaremos qual foi a primeira competência em que essas condições foram satisfeitas. Observa-se que entre junho e novembro de 2019 há um número considerável de médicos migrando para as cidades de designação.

A partir dessa identificação, filtraremos a base apenas com esses médicos.

```{r}

# Convertendo competência para formato data

base_tratada$COMPETEN <- 
  as.Date(paste0(base_tratada$COMPETEN, "01"), 
          format = "%Y%m%d")

# metodo para identificar quem foi selecionado e de fato foi para a cidade a qual foi alocado no programa, inclusive sendo alocado em APS

temp <- 
  base_tratada |> 
    mutate(aps = if_else((TP_UNID == "02" |
                          TP_UNID == "01" |
                          TP_UNID == "32" |
                          TP_UNID == "71" |
                          TP_UNID == "72" |
                          TP_UNID == "74"), 
                         "APS", "Outros")) |> 
  mutate(ano = year(COMPETEN)) |> 
  filter(ano == 2019) |> 
  mutate(assumiu_programa = 
           if_else(ano == 2019 &
                   aps == 'APS' &
                   CODUFMUN == ibge_aloc, 
                   "Foi alocado", 
                   "Não foi alocado")) 

temp2 <- temp |> 
        filter(assumiu_programa == "Foi alocado") |> 
        group_by(CPF_PROF) |> 
        slice_min(COMPETEN)

vetor_saida <- 
  lista_cns_cpf |> 
  anti_join(temp2, by = c("CPF_PROF")) 

dim(vetor_saida)

```

Cerca de 387 indivíduos saíram da base, pois não assumiram o programa. Abaixo temos alguns exemplos.

-   A médica, cujo código CPF criptografado é "\<82\>\<83\>~\<82\>\<80\>~\<80\>}{{", foi designada ao município de José de Freitas (PI). Porém, ao longo do ano de 2019 ela não esteve nenhum mês no município. Os primeiros registros dela após 2019 foram apenas no ano de 2022 em Epitaciolândia (AC).

```{r}

base_tratada |> 
  filter(year(COMPETEN) >= 2019) |> 
  filter(CPF_PROF == "<82><83>~<82><80>~<80>}{{") |> 
   select(COMPETEN, uf_destino,
          municipio_destino, uf_sigla,
          municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

-   A médica, cujo código CPF_PROF é "\<82\>{\<84\>\<83\>\<82\>\~\<83\>\<81\>\<82\>{{", foi designada ao município de Mesquita (RJ). Porém, ao longo do ano de 2019 ela não esteve nenhum mês no município. No ano de 2019 ela estava atuando unicamente no Rio de Janeiro (RJ).

```{r}

base_tratada |> 
  filter(year(COMPETEN) >= 2019) |> 
  filter(CPF_PROF == "<82>{<84><83><82>~<83><81><82>{{") |> 
  select(COMPETEN, uf_destino, municipio_destino, uf_sigla,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

-   A médica, cujo código CPF_PROF é "\~}}\|\|}}}{", foi designada ao município de Alvorada (RS). Porém, ao longo do ano de 2019 ela não esteve nenhum mês no município. No ano de 2019 ela estava atuando unicamente em Rio Branco (AC).

```{r}

base_tratada |> 
  filter(year(COMPETEN) >= 2019) |> 
  filter(CPF_PROF == "~}}||}}}{") |> 
  select(COMPETEN, uf_destino, 
         municipio_destino, uf_sigla,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

Logo retirando os 363 casos acima, mantemos 1670 indivíduos na base. Desta forma, mantivemos uma base 203.350 observações.

```{r}

# Filtrando a base apenas com os médicos ingressantes

base_tratada2 <- 
    base_tratada |> 
    filter(CPF_PROF %in% temp2$CPF_PROF) |> 
    janitor::clean_names() |> 
    mutate(ano = year(competen)) |> 
    mutate(ch_total = horahosp + 
                      hora_amb + 
                      horaoutr) |> 
    select(ano, competen, codufmun, cnes, 
           municipio_pad, ibge_aloc, 
           municipio_destino, uf_destino, 
           cnes, tp_unid, fantasia, nomeprof, 
           cns_prof, cpf_prof, 
           data_nascimento, data_formacao, 
           participou_pmmb, 
           sexo, ch_total) |>
    filter(competen >= '2019-01-01')

```

## 1.2. Variáveis de desfecho

Criamos duas variáveis de desfecho:

1.  churn (variável dicotômica, permanece ou não no município ao qual foi alocado, após 5 anos);

2.  tempo de permanência (variável quantitativa, medida em meses);

### 1.2.1. Churn

A variável de desfecho foi construída com o objetivo de verificar se a pessoa sai do município onde foi designada cerca de cinco anos após o início do programa (final de 2024). Lembrando que o programa tem duração de 48 meses.

Cerca de 562 saiu da região e 898 permanece na região.

```{r}

churn <- 
  base_tratada2 |> 
  filter(competen == "2024-12-01") |> 
  mutate(churn = 
           if_else(codufmun == ibge_aloc, 
                   "permanece", 
                   "migrou")) |> 
  select(cpf_prof, churn) |> 
  distinct() |>  
# Se o individuo estiver atuando no mesmo municipio e em outra localidade limitrofe, vamos marcar como "permanece". O codigo abaixo faz isso 
  arrange(cpf_prof, churn) |> 
  group_by(cpf_prof) |> 
  slice(1) |> 
  ungroup()

table(churn$churn)

```

É importante observar que o somatório é 1460 (1130 + 330), ou seja, menor que o número inicial. Isso decorre, pois alguns profissionais podem ter saído da base (ex.: migrou do país, migrou de atuação, aposentou, óbito, passou a atuar em locais que não possuem registro no CNES).

Abaixo colocamos alguns exemplos que ocorreram isso.

O primeiro caso é um profissional identificado por "\<83\>\<82\>\<82\>\|\<81\>\<83\>\<84\>{" que ficou poucos meses em Olinda (PE), município ao qual foi alocado. Porém, os seus registros na base se encerram em maio de 2023.

```{r}

teste_churn <- temp2 |> 
  left_join(churn, 
            by = c("CPF_PROF"="cpf_prof"))

base_tratada |> 
  filter(CPF_PROF == "~<83><82>~<82>|<81><83><84>{") |> 
  filter(year(COMPETEN) >= 2019) |> 
  select(COMPETEN, municipio_destino, uf_destino,
          municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

O segundo caso é um profissional identificado por "\<82\>{\<84\>\<84\>}{\<80\>\<82\>\<83\>" que ao final do ano de 2024 não estava mais na base, apesar de ter trabalhado muito tempo em Utinga (BA).

```{r}

base_tratada |> 
  filter(CPF_PROF == "<82>{<84><84>}{<80><82><83>") |> 
  filter(year(COMPETEN) >= 2019) |> 
  select(COMPETEN,
         municipio_destino,
         uf_destino,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  DT::datatable()

```

A base a seguir exclui os casos de indivíduos que não estavam atuando mais no final de 2024 (independente de estarem no município onde foram alocados ou não), que resulta em 1460 indivíduos.

```{r}

base_tratada3 <- base_tratada2 |>    
  filter(cpf_prof %in% churn$cpf_prof) 

```

### 1.2.2. Tempo de permanência

A variável de desfecho foi construída com o objetivo de verificar se a pessoa sai do município onde foi designada cerca de 5 anos após o início do programa. Lembrando que o programa tem duração de 48 meses.

```{r}

meses_trabalho <-    
  base_tratada3 |>      
  group_by(cpf_prof) |>       
  mutate(         
    meses_no_local_alocado =            
      interval(             
        min(competen[codufmun == ibge_aloc]),       
        max(competen[codufmun == ibge_aloc])) %/%           months(1) + 1) |>       
  ungroup() |>    
  select(cpf_prof,           
         meses_no_local_alocado) |>      
  distinct() 

mean(meses_trabalho$meses_no_local_alocado)

```

O exemplo que mostramos anteriormente é evidente quanto a isso. O profissional atuou no município de destino por sete meses, entre agosto de 2019 e fevereiro de 2020. Porém, os últimos registros são este ano. Após isso, não aparece mais na base.

```{r}

base_tratada |> 
  filter(CPF_PROF == "~<83><82>~<82>|<81><83><84>{") |> 
  filter(year(COMPETEN) >= 2019) |> 
  select(COMPETEN, 
         municipio_destino, 
         uf_destino,
         municipio_pad) |> 
  arrange(COMPETEN) |> 
  filter(municipio_pad == "OLINDA") |> 
  DT::datatable()

```

A média do tempo de atuação no mesmo local é de aproximadamente 43 meses.

```{r}

a <- meses_trabalho |>    
  ggplot(aes(y = meses_no_local_alocado)) +  
  geom_boxplot() +    
  ylab("Meses no local de trabalho")  

b <- meses_trabalho |>    
  ggplot(aes(x = meses_no_local_alocado)) +   
  geom_histogram() +    
  xlab("Meses no local de trabalho") +   
  ylab("Frequência")  

a + b
```

Aqui vamos começar a organizar a base então. Lembrando que pelo número de observações serão 1460 linhas.

```{r}

base_vd <- 
  cns_inscricao |> 
  filter(CPF_PROF %in% churn$cpf_prof) |> 
  left_join(meses_trabalho,
            by = c("CPF_PROF"="cpf_prof")) |> 
  left_join(churn,
            by = c("CPF_PROF"="cpf_prof"))

```

Vamos fazer algumas análises exploratórias iniciais.

Percebe-se que em alguns estados houve uma migração mais elevada, que são os casos de Roraima, Sergipe e Alagoas.

```{r}

base_vd |> 
  group_by(churn, uf_destino) |> 
  count() |> 
  ggplot(aes(x = uf_destino, 
             y = n, fill = churn)) +
  geom_col(position = "fill") +
  coord_flip() + 
  xlab("UF") +
  ylab("Percentual migração vs permanência") + 
  theme_minimal()

```

Em relação ao tempo média de permanência, temos o seguinte gráfico.

```{r}

base_vd |> 
  group_by(uf_destino) |> 
  summarise(tempo = mean(meses_no_local_alocado)) |> 
  ggplot(aes(x = fct_reorder(uf_destino, tempo), 
             y = tempo)) +
  geom_col() +
  coord_flip() +
  xlab("UF") + 
  ylab("Tempo médio de permanência") +
  theme_minimal()

```

A partir da próxima seção vamos agregar algumas variáveis a nível indivíduo.

## 1.3. Atributos a nível indivíduo

Vamos começar a levantar alguns atributos a nível indivíduo.

### 1.3.3 Idade

Adicionando a variável de idade. Percebemos que as pessoas que migram, tendem a ser mais novas.

```{r}

base_vd <- base_vd |> 
  mutate(idade = round(interval(data_nascimento,as.Date("2024-12-12"))/years(1)))

base_vd |> 
  group_by(churn) |> 
  summarise(idade_media = mean(idade),
            idade_sd = sd(idade))

```

Os gráficos abaixo ratificam os resultados.

```{r}

base_vd |> 
  ggplot(aes(x = idade, fill = churn)) + 
  geom_histogram(binwidth = 1, 
                 color = "black",
                 alpha = 0.7) +  
  geom_vline(xintercept = 39, 
             linetype = "dashed", 
             color = "black") +  
  geom_vline(xintercept = 45, 
             linetype = "dashed", 
             color = "black") +  
  annotate("text", 
           x = 39, 
           y = Inf, 
           label = "Migrou", 
           vjust = 1.5, 
           hjust = 1.1,
           fontface = "bold") +  
  annotate("text", x = 45, y = Inf, 
           label = "Permanece", 
           vjust = 3.5, 
           hjust = -0.10, 
           fontface = "bold") +  
  theme_minimal()

```

### 1.3.2 Atuação prévia

Vamos acessar para ver se aquele indivíduo atuou na cidade onde foi destinado em anos anteriores a 2019. Além disso, verificamos quantos meses ele atuou nesta localidade.

```{r}

# estou usando 'base_tratada' e nao a 'base_tratada3' pois la retiramos os registros antes de 2019 para fazer uns tratamentos 

atuacao <- 
    base_tratada |> 
    mutate(ano = year(COMPETEN)) |> 
    filter(ano < 2019 & 
             CODUFMUN == ibge_aloc) |> 
    group_by(COMPETEN, ibge_aloc, CPF_PROF) |> 
    count() |> 
    group_by(ibge_aloc, CPF_PROF) |> 
    count() |> 
    mutate(atuacao_previa_no_municipio = "Sim") |> 
    mutate(anos_atuacao_previa_no_municipio = n/12) |> 
    ungroup() |> 
    select(-ibge_aloc)

```

Existem alguns casos que o profissional atuou por mais de 12 anos.

Depois de preparar a base, vamos juntar à base original.

```{r}

base_atributos <- 
      base_vd |> 
      left_join(atuacao, 
                by = c("CPF_PROF")) |> 
      mutate(atuacao_previa_no_municipio = 
             if_else(atuacao_previa_no_municipio == 
                       "Sim","Sim","Não")) |> 
      select(-n) |> 
      janitor::clean_names()

base_atributos$atuacao_previa_no_municipio[is.na(base_atributos$atuacao_previa_no_municipio)] <- "Não"

base_atributos$anos_atuacao_previa_no_municipio[is.na(base_atributos$anos_atuacao_previa_no_municipio)] <- 0

```

### 1.3.3 Quantidade média de vínculos enquanto está na mesma cidade

Para isso, vamos verificar, desde de meados de 2019, quantos vínculos o indivíduos tinha por competência no mesmo município onde ele foi alocado.

```{r}

vinculos_cidade <- 
  base_tratada3 |> 
  filter(competen > '2019-05-01') |> 
  group_by(cpf_prof, competen, 
           codufmun, ibge_aloc) |> 
  count() |> 
  ungroup() |> 
  filter(codufmun == ibge_aloc) |> 
  select(cpf_prof, competen, n) |> 
  group_by(cpf_prof) |> 
  summarise(media_vinculos_mes = mean(n))

```

Juntando com a base tratada.

```{r}

base_atributos <- 
  base_atributos |> 
  left_join(vinculos_cidade, 
            by = c("cpf_prof"))

```

A maioria dos registros ficou apenas em um só estabelecimento ao longo de todo o período. O profissional identificado pelo código "\<80\>\<84\>\~\~\<80\>}\<83\>\<84\>}\<82\>}" é um bom exemplo. O profissional mudou de unidade (sempre na APS), mas sempre com apenas um vínculo.

```{r}

base_tratada3 |> 
  filter(cpf_prof == "<80><84>~~<80>}<83><84>}<82>}") |> 
  select(competen, 
         uf_destino,
         municipio_destino,
         codufmun,
         municipio_pad,
         fantasia) |> 
  DT::datatable()
  
  

```

Em contrapartida, o profissional identificado pelo código "{}\~}}\|\<80\>\<82\>\~" começa a atuar na APS em junho de 2019. Ao longo de todo o período, a pessoa se mantém no mesmo município que foi alocada (Mutum-MG). Inclusive, é o tipo de caso que já atuava antes no mesmo município.

Todos os meses ele atuava no município, vinculado não só a APS, mas outros estabelecimentos.

```{r}

base_tratada3 |> 
  filter(cpf_prof == "{}~}}|<80><82>~") |> 
  select(competen, 
         uf_destino,
         municipio_destino,
         codufmun,
         municipio_pad,
         fantasia,
         ch_total) |> 
  DT::datatable()

```

Observa-se que há maior variedade no número de vínculos entre os profissionais que permaneceram.

```{r}

base_atributos |> 
  ggplot(aes(y = media_vinculos_mes,
             fill = churn)) +
  geom_boxplot() +
  theme_minimal() + 
  ylab("Média de vínculos por mês no\n mesmo local") + 
  theme(axis.text.x = element_blank())
  
```

Os resultados abaixos ratificam os resultados do gráfico.

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(media_vinculos = 
              mean(media_vinculos_mes),
            sd_vinculos = 
              sd(media_vinculos_mes))

```

# ALEF!!!! CONTINUAR POR AQUI

### 1.2.6 Renovação

A próxima etapa será identificar os profissionais que tiveram a permanência no programa prorrogada por mais um ano. Infelizmente, como a única informação nos resultados de prorrogação que identifica o médico é o nome, realizaremos o left join utilizando essa variável.

```{r}

prorrogacao <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/prorrogacao_ciclo18.xlsx")

base_atributos <- 
  base_atributos |>   
  left_join(prorrogacao, 
            by = c("nome" = "NOME")) |>   
  mutate(Prorrogado = ifelse(is.na(Prorrogado), 
                             "NÃO", 
                             Prorrogado))


base_atributos |>
  group_by(Prorrogado) |> 
  summarise(quantidade = n()) |> 
  mutate(percentual = round(quantidade/sum(quantidade)*100,2)) |> 
  DT::datatable()

```

Dos 1460 médicos, 623 (42,64%) tiveram sua adesão prorrogada por mais um ano e 837 (57,33%) não prorrogaram.

Abaixo visualizaremos a informação desagregada por churn.

```{r}
base_atributos |> 
  group_by(churn, Prorrogado) |> 
  count() |> 
  ggplot(aes(x = churn, 
             y = n, fill = Prorrogado)) +
  geom_col(position = "fill") +
  coord_flip() + 
  theme_minimal()

```

### 1.2.7. Tempo formado

O próximo passo é verificar quanto tempo a pessoa já está formada.

```{r}

anos_formado <- 
  base_tratada2 |>
  mutate(
    data_formacao = dmy(paste0("01/", data_formacao)), 
    competen = ymd(competen)) |>
  group_by(cpf_prof) |>
  slice_min(order_by = competen, with_ties = FALSE) |>
  ungroup() |>
  mutate(anos_formacao = 
           as.numeric(difftime(competen, 
                               data_formacao,
                               units = "days")) / 365.25) |> 
  mutate(anos_formacao = if_else(anos_formacao < 0, 
                                 0,
                                 anos_formacao)) |> 
  select(cpf_prof, anos_formacao)


print(paste("Média:", round(mean(anos_formado$anos_formacao),2)))
print(paste("Mediana: ", round(median(anos_formado$anos_formacao),2)))
```

A média do tempo de formação são de 5,2 anos, no entanto como há muitos outliers calcula-se também a mediana que é de 1,8 anos, dessa forma, observa-se que a maioria dos médicos tem até 2 anos de formação.

```{r}
a <- anos_formado |>    
  ggplot(aes(y = anos_formacao)) +  
  geom_boxplot() +    
  ylab("Anos de formação")  

b <- anos_formado |>    
  ggplot(aes(x = anos_formacao)) +   
  geom_histogram() +    
  xlab("Anos de formação") +   
  ylab("Frequência")  

a + b
```

Juntando a base.

```{r}

base_atributos <- 
  base_atributos |> 
  left_join(anos_formado, 
            by = c("cpf_prof"))
```

Desagregando pelo churn é possível observar que os anos de formação dos indivíduos que permanceram é maior em relação aos que migraram.

```{r}
base_atributos |> 
  ggplot(aes(y=anos_formacao, fill = churn)) +
  geom_boxplot() +
  theme_minimal() + 
  ylab("Anos de formação") +
  theme(axis.text.x = element_blank())
  
```

A tabela abaixo quantifica a diferença dos anos de formação por churn.

```{r}

base_atributos |> 
  group_by(churn) |> 
  summarise(média_anos_formacao = mean(anos_formacao),
            sd = sd(anos_formacao)) |> 
  DT::datatable()
```

## 1.3. Atributos a nível estabelecimento

Nessa seção, serão levantadas as variáveis associadas aos estabelecimentos que receberam médicos do programa, tais como, número de leitos e profissionais.

### 1.3.1 Número de leitos das unidades

Este passo consiste em identificar qual o número de leitos nas unidades de APS as quais o indivíduo foi alocado.

``` sql
SELECT 
    substr(lt.COMPETEN, 1, 4) as ano,
    lt.cnes,
    m.uf_sigla,
    CASE
        WHEN LENGTH(m.cod_municipio) = 7 THEN SUBSTR(m.cod_municipio, 1, 6)
        WHEN m.cod_municipio LIKE '53%' THEN '530010'
        ELSE m.cod_municipio
    END AS cod_ibge,    
    m.municipio,
    SUM(lt.QT_SUS) AS quantidade_sus,
    SUM(lt.QT_NSUS) AS quantidade_nao_sus,
    SUM(lt.QT_SUS) + SUM(lt.QT_NSUS) AS qt_total
FROM
    Dados.cnes.LT lt 
LEFT JOIN 
    "Open Analytics Layer".Territorial."Hierarquia completa dos municípios" m 
    ON lt.CODUFMUN = CAST(m.cod_municipio AS CHAR)
WHERE 
    substr(lt.COMPETEN, 5, 2) = '01' AND 
    substr(lt.COMPETEN, 1, 4) > 2018 AND
    cnes IN (lista)
GROUP BY
    ano,
    m.uf_sigla,
    cod_ibge,
    m.municipio,
    lt.cnes
```

Baixando dados de leitos.

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_leitos_v2"'



leitos <- sqlQuery(channel, query, 
                     as.is = TRUE)

```

Acessando dados de leitos das unidades de APS as quais os indivíduos foram alocados.

```{r}

leitos_unidades <- 
  leitos |> 
  mutate(Ano = as.numeric(Ano)) |> 
  filter(CNES %in% temp2$CNES) |> 
  filter(Ano == 2019) |> 
  select(CNES, leitos_instalacao_fisica_urgencia)
  

base_atributoT <- leitos_unidades |>
  left_join(base_atributos, 
            by = c("CNES" = "cnes"))
```

### 1.3.2 Número de profissionais das unidades

Este passo consiste em identificar qual o número de profissionais nas unidades de APS as quais o indivíduo foi alocado.

``` sql
WITH ch_cnes_selecionados 

AS(
    SELECT CNES,
        CODUFMUN, 
        PF.NOMEPROF,
        PF.CPF_PROF,
        CBO,
        CASE 
            WHEN substr(CBO, 1, 4) = '2235' 
            THEN 'Enfermeiro' 
            WHEN substr(CBO, 1, 4) = '3222' 
            THEN 'Técnico ou Auxiliar de Enfermagem'
            WHEN substr(CBO, 1, 4) = '2232' 
            THEN 'Cirurgião Dentista'
            WHEN CBO = '515105' 
            THEN 'Agente Comunitário de Saúde'
        END AS categoria,
        substr(COMPETEN, 1, 4) AS ANO,
        CAST(PF.HORAHOSP + PF.HORAOUTR + PF.HORA_AMB AS FLOAT) AS CH_TOTAL
    FROM Dados.cnes.PF
    WHERE 
        substr(PF.COMPETEN, 5, 2) = '01' AND
        substr(PF.COMPETEN, 1, 4) > 2018 AND 
        (CBO = '515105' OR 
        substr(PF.CBO, 1, 4) = '2235' OR 
        substr(PF.CBO, 1, 4) = '2232' OR 
        PF.CBO = '322205' OR
        PF.CBO = '322210' OR
        PF.CBO = '322215' OR
        PF.CBO = '322220' OR
        PF.CBO = '322245' OR
        PF.CBO = '322230' OR
        PF.CBO = '322235' OR
        PF.CBO = '322250')) 

SELECT a.ANO, 
       a.CNES, 
       b.FANTASIA,
       c.uf_sigla,
       a.CODUFMUN,
       c.municipio, 
       a.categoria,   
       SUM(CH_TOTAL) AS CH,
       SUM(CH_TOTAL)/40 AS FTE40
FROM ch_cnes_selecionados a
    LEFT JOIN Dados.cnes.CADGER b
        ON a.CNES = b.CNES
    LEFT JOIN "Open Analytics Layer".Territorial."Hierarquia completa dos municípios" c
        ON a.CODUFMUN = CAST(c.cod_municipio AS CHARACTER)
GROUP BY 
        ANO,
        CNES, 
        fantasia,
        uf_sigla,
        CODUFMUN, 
        municipio,
        categoria
```

asfd

```{r}

# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_equipe_cnes"'

equipe_saude <- sqlQuery(channel, 
                         query,
                         as.is = TRUE)


```

asdf

```{r}

equipe_saude2 <- 
    equipe_saude |> 
    select(CNES, ANO, categoria, FTE40) |> 
    mutate(categoria = 
             case_when(
               categoria == 
                 "Técnico ou Auxiliar de Enfermagem" ~ 
                 "tec_aux_enf",
               categoria == 
                 "Cirurgião Dentista" ~ "dentista",
               categoria == "Agente Comunitário de Saúde" ~
                 "agente_saude",
               categoria == "Enfermeiro" ~ "enfermeiro",
               TRUE ~ NA)) |> 
    mutate(FTE40 = ifelse(is.na(FTE40), 0, FTE40))
  
equipe_saude3 <- 
    equipe_saude2 |> 
    filter(CNES %in% base_tratada10$cnes) |> 
    group_by(CNES, categoria) |> 
    summarise(FTE40 = mean(FTE40)) |> 
    ungroup() |> 
    pivot_wider(names_from = categoria, 
                values_from = FTE40) |> 
    mutate(across(2:5, ~ ifelse(is.na(.), 0, .))) 

```

base

```{r}

base_tratada12 <- 
  base_tratada11 |> 
    left_join(equipe_saude3,
              by = c("cnes"="CNES"))
  
  
```

### 1.3.2 Número de equipamentos das unidade

``` sql
WITH 
      tratamento_inicial
  AS(
      SELECT 
          CONCAT(a.TIPEQUIP, a.CODEQUIP) AS id_equipamento,
          a.CNES, 
          a.CODUFMUN,
          a.TPGESTAO, 
          a.TP_UNID, 
          CAST(a.QT_USO AS INT) AS QT_USO, 
          a.COMPETEN, 
          a.uf,
          b.no_grupo, 
          b.no_equip
      FROM Dados.CNES.EQ a
          LEFT JOIN Dados.cnes."tp_equip.parquet" b
          ON id_equipamento = CAST(id_equip AS CHARACTER)
      WHERE SUBSTR(COMPETEN, 5, 2) = '01' AND
            CAST(SUBSTR(COMPETEN, 1, 4) AS INTEGER) >= 2019
  )
  
  SELECT CNES,
         ID_EQUIPAMENTO, 
         NO_EQUIP, 
         NO_GRUPO,
         AVG(QT_USO) AS QT_EQUIPAMENTO_USO
  FROM tratamento_inicial
  GROUP BY CNES,
        ID_EQUIPAMENTO, 
        NO_EQUIP,
        NO_GRUPO
  ORDER BY qt_equipamento_uso DESC
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_equipamentos"'

equipamentos <- sqlQuery(channel, 
                         query,
                         as.is = TRUE)
```

```{r}



teste <- equipamentos |> 
  filter(is.na(NO_GRUPO)) |> 
  distinct(ID_EQUIPAMENTO)
```

## 1.4. Atributos a nível município

Nessa seção serão agregadas as variáveis a nível municipal a partir de diveras fontes. Divideremos esses atributos em grupos.

### 1.4.1 Indicadores econômicos

#### 1.4.1.1 População e porte

A partir de dados do Censo 2022 do IBGE identificaremos a população dos municipios, e classificaremos por porte de acordo com a população.

```{r}
#Carregando a base de contigente populacional
pop_mun <- 
  read_excel("~/GitHub/sa_maismedicos/01_dados/pop_municipios.xlsx") |> 
  mutate(cod_mun = substr(cod_mun, 1, 6)) |> 
  mutate(populacao = as.numeric(populacao))

base_atributos$ibge_aloc <- as.character(base_atributos$ibge_aloc)

base_atributos <- base_atributos |> 
  left_join(pop_mun, by = c("ibge_aloc" = "cod_mun")) |> 
  select(-mun) |> 
  mutate(porte = 
           case_when((populacao < 20000) ~ "PP-I",
                     (populacao >= 20000 & 
                      populacao < 50000) ~ "PP-II",
                     (populacao >= 50000 & 
                      populacao < 100000) ~ "MP",
                     (populacao >= 100000 & 
                      populacao < 900000) ~ "GP",
                     (populacao >= 900000) ~ "Metrópole",
                      TRUE ~ "Outros casos"))

base_atributos |> 
  group_by(porte) |> 
  count() |> 
  summarise(quantidade = n) |> 
  mutate(percentual = round(quantidade/sum(quantidade)*100,2)) |> 
  arrange(desc(percentual)) |> 
  DT::datatable()
```

Observa-se que a maioria dos médicos foram alocados em cidades de até 50 mil habitantes, no entanto a permanência dos profissionais é maior nas cidades com mais de 100 mil habitantes, conforme pode ser visto abaixo.

```{r}

base_atributos |> 
  group_by(churn, porte) |> 
  count() |> 
  ungroup() |> 
  ggplot(aes(x = reorder(porte, -n, sum), y = n, fill = churn)) +
  geom_col(position = "fill") + 
  coord_flip()
```

Observa-se que o município com a maior população é São Gonçalo do Rio de Janeiro com 896.744 habitantes, e que recebeu 3 médicos do programa.

```{r}
base_atributos |> 
  filter(populacao == max(populacao)) |> 
  select(nome, uf_destino, municipio_destino, populacao, porte) |> 
  DT::datatable()
```

Observa-se que o município com a menor população é Nova Aliança do Ivai do Paraná com 1.323 habitantes, e que recebeu apenas um médico do programa.

```{r}
base_atributos |> 
  filter(populacao == min(populacao)) |> 
  select(nome, uf_destino, municipio_destino, populacao, porte) |> 
  DT::datatable()
```

#### 1.4.1.2 PIB per capita

``` sql
SELECT codigo_municipio, 
       ano, 
       produto_interno_bruto_capital_precos_correntes_1 AS pib_percapita
       
FROM Dados.pib."pib_2010_2021.parquet"
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_pibpercapita"'



pib_percapita <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

```{r}

pib_percapita <- pib_percapita |> 
  mutate(pib_percapita = as.numeric(pib_percapita)) |> 
  mutate(codigo_municipio = substring(codigo_municipio,1,6)) |> 
  filter(ano == "2019") |> 
  select(-ano)

base_atributos <- base_atributos |> 
  left_join(pib_percapita, by = c("ibge_aloc" = "codigo_municipio"))

print(paste("Média:", round(mean(base_atributos$pib_percapita),2)))
```

A média do PIB per capita dos municípios é de R\$ 17.653,51.

```{r}
a <- base_atributos |>    
  ggplot(aes(y = pib_percapita)) +  
  geom_boxplot() +    
  ylab("PIB per capita")  

b <- base_atributos |>    
  ggplot(aes(x = pib_percapita)) +   
  geom_histogram() +    
  xlab("PIB per capita") +   
  ylab("Frequência")  

a + b
```

Abaixo é possível identificar o município com o maior PIB per capita que é de R\$ 353.505,22 com uma população de 8.142 habitantes.

```{r}
base_atributos |> 
  filter(pib_percapita == max(pib_percapita)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita) |> 
  DT::datatable()
```

Abaixo é possível identificar o município com o menor PIB per capita que é de R\$ 4.575,16 com uma população de 17.432 habitantes.

```{r}
base_atributos |> 
  filter(pib_percapita == min(pib_percapita)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita) |> 
  DT::datatable()
```

#### 1.4.1.3 População ocupada

Os dados da população ocupada foram coletados da Estatísticas do Cadastro Central de Empresas (CEMPRE) do IBGE por meio do SIDRA, tabela 1685.

E calculamos o percentual da população ocupada com os dados do Censo 2022.

```{r}
pop_ocupada_mun <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/pop_ocupada_mun.xlsx") |> 
  select(-municipio) |> 
  mutate(across(-cod_ibge, as.numeric)) |>  # Converte todas as colunas, exceto cod_ibge, para "character"
  pivot_longer(
    cols = -cod_ibge,
    names_to = "ano",
    values_to = "pop_ocupada"
  ) |> 
  filter(ano == "2019") |> 
  mutate(cod_ibge = substring(cod_ibge,1,6)) |> 
  select(-ano)

base_atributos <- 
  base_atributos |> 
  left_join(pop_ocupada_mun, 
            by = c("ibge_aloc" = "cod_ibge")) |> 
  mutate(tx_pop_ocupada = pop_ocupada/populacao) |> 
  select(-pop_ocupada)

print(paste("Média:", round(mean(base_atributos$tx_pop_ocupada),2)))
```

A média das taxas de ocupação dos municípios é de 12%, sendo que ela é maior nos municípios em que os médicos permanecem conforme boxplot abaixo.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = tx_pop_ocupada,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  xlab("Percentual") +
  ylab("Taxa de ocupação") +
  theme(axis.text.x = element_blank())

b <- base_atributos |>    
  ggplot(aes(x = tx_pop_ocupada)) +   
  geom_histogram() +    
  xlab("Taxa de ocupação") +   
  ylab("Frequência")  

a + b
```

Abaixo pode-se olhar a diferença em termos de média.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(taxa_ocupacao = round(mean(tx_pop_ocupada)*100,2)) |> 
  DT::datatable()
```

O município com a maior taxa de ocupação é Sapezal do Mato Grosso com 37,78%.

```{r}
base_atributos |> 
  filter(tx_pop_ocupada == max(tx_pop_ocupada)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, tx_pop_ocupada) |> 
  DT::datatable()
```

O município com a menor taxa de ocupação é Ipixuna do Amazonas com 1,41%.

```{r}
base_atributos |> 
  filter(tx_pop_ocupada == min(tx_pop_ocupada)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, tx_pop_ocupada) |> 
  DT::datatable()
```

### 1.4.2 Indicadores de saúde

A seguir, as variáveis relacionadas a qualidade e acesso à saúde.

#### 1.4.2.1 Cobertura de plano de saúde

A partir dos dados da Agência Nacional de Saúde, agregaremos na nossa base a taxa de cobertura de plano de saúde que é resultado do número de planos de saúde dividido pela população.

``` sql

SELECT cod_ibge, taxa FROM "Open Analytics Layer".Infraestrutura."Cobertura Plano de Saúde"
```

```{r}

# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_cobertura_plano_saude"'



cobertura_saude <- sqlQuery(channel, query, 
                     as.is = TRUE)


```

```{r}
cobertura_saude <- cobertura_saude |> 
  rename(cobertura_saude = taxa) |> 
  mutate(cobertura_saude = as.numeric(cobertura_saude))

base_atributos <- base_atributos |> 
  left_join(cobertura_saude, by = c("ibge_aloc" = "cod_ibge"))

cat("Média:",mean(base_atributos$cobertura_saude))
```

A média de cobertura de saúde dos municípios é de 11,5%, e quando desagregado por churn é maior entre os municípios com indivíduos que permaneceram conforme pode ser visto abaixo.

```{r}
a <- base_atributos |> 
      ggplot(aes(x = cobertura_saude,
                 fill = churn)) +
      geom_boxplot() +
      coord_flip() +
      theme(legend.position = "top") +
      theme(axis.text.x = element_blank()) +
      ylab("Cobertura de saúde") +
      xlab("Percentual")

b <- base_atributos |> 
  ggplot(aes(x = cobertura_saude)) +
  geom_histogram() +
    ylab("Frequência") + 
  xlab("Cobertura de saúde")

a + b
```

Abaixo é possível observar a diferença em termos de média.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(cobertura_saude = round(mean(cobertura_saude),2)) |> 
  DT::datatable()
```

O município com a maior taxa de cobertura de saúde é Paraubebas do Pará com 90%.

```{r}
base_atributos |> 
  filter(cobertura_saude == max(cobertura_saude)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, cobertura_saude) |> 
  DT::datatable()
```

O município com a menor taxa de cobertura de saúde é Santa Isabel do Rio Negro com 0,13%.

```{r}
base_atributos |> 
  filter(cobertura_saude == min(cobertura_saude)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, cobertura_saude) |> 
  DT::datatable()
```

#### 1.4.2.2 Número vagas de medicina

A seguir, adicionaremos a variável número de vagas de medicina por município a partir de dados do INEP, e calcularemos o número de vagas por mil habitantes.

``` sql
SELECT cod_ibge, SUM(vagas) AS vagas_medicina FROM "Open Analytics Layer"."Educação"."Quantidade de vagas, matriculados, concluintes e inscritos em curso superior por município"
WHERE curso = 'Medicina'
GROUP BY(cod_ibge)
```

```{r}
# codigo para acessar dados de datalake proprio 

dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")


channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
                                     HOST=%s;
                                     PORT=%s;
                                     UID=%s;
                                     PWD=%s;
                                     AUTHENTICATIONTYPE=Basic Authentication;
                                     CONNECTIONTYPE=Direct", 
                         dremio_host, 
                         dremio_port, 
                         dremio_uid, 
                         dremio_pwd))

query <- 'SELECT * FROM "@alef_santos"."pmmb_vagas_medicina"'



vagas_medicina <- sqlQuery(channel, query, 
                     as.is = TRUE)
```

```{r}

base_atributos <- base_atributos |> 
  left_join(vagas_medicina, by = c("ibge_aloc" = "cod_ibge")) |> 
  mutate(vagas_medicina = as.numeric(vagas_medicina)) |> 
  mutate(vagas_medicina_milhab = (vagas_medicina/populacao)*1000) |> 
  mutate(vagas_medicina = ifelse(is.na(vagas_medicina), 0, vagas_medicina)) |> 
  mutate(vagas_medicina_milhab = ifelse(is.na(vagas_medicina_milhab), 0, vagas_medicina_milhab)) |> 
  select(-vagas_medicina)

cat("Média:", mean(base_atributos$vagas_medicina_milhab))
```

A média de vagas de medicina por mil habitantes é de 0,8 e visualmente pelo boxplot abaixo não é possível observar diferença desagregada por churn, entende-se apenas que a maioria dos municípios não tem vagas em cursos de medicina.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = vagas_medicina_milhab,
             fill = churn)) +
  geom_boxplot() +
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  ylab("Vagas de medicina por mil hab.") +
  xlab("Número de vagas")

b <- base_atributos |> 
  ggplot(aes(x = vagas_medicina_milhab)) +
  geom_histogram()

a + b
```

Apenas abaixo conseguimos identificar uma diferença: as cidades onde os médicos permaneceram tiveram, em média, mais vagas de medicina em comparação às cidades de onde migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(vagas_medicina = round(mean(vagas_medicina_milhab),2)) |>
  DT::datatable()
```

A cidade com maior número de vagas de medicina foi Cajazeiras da Paraiba com 22 por mil habitantes.

```{r}
base_atributos |> 
  filter(vagas_medicina_milhab == max(vagas_medicina_milhab)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, vagas_medicina_milhab) |> 
  DT::datatable()
```

#### 1.4.2.3 Orçamento per capita para a saúde

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o DataSUS de 2019. E o cálculo realizado é: Gasto total em saúde ÷ População total do município.

```{r}
orcamento_saude <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, orcamento_saude) |> 
  mutate(id = substr(id, 1, 6))


base_atributos <- base_atributos |> 
  left_join(orcamento_saude, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

cat("Média", mean(base_atributos$orcamento_saude))
```

A média de orçamento de saúde dos municípios é de R\$ 653,21 e conforme boxplot abaixo não é possível identificar diferença desagregada por churn.

```{r}
a <- base_atributos |> 
  ggplot(aes(x = orcamento_saude,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Reais (R$)") +
  ylab("Orçamento de saúde")

b <- base_atributos |> 
  ggplot(aes(x= orcamento_saude)) + 
  geom_histogram() +
  xlab("Orçamento de saúde") +
  ylab("Frequência")

a + b 
```

Em termos de média, a diferença do orçamento per capita é pequena, sendo maior no caso dos municípios de indivíduos que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(orcamento_saude = 
              round(mean(orcamento_saude),2)) |> 
  DT::datatable()
```

O município com o maior orçamento de saúde per capita é Santa Margarida do Sul do Rio Grande do Sul com R\$ 5.561,87.

```{r}
base_atributos |> 
  filter(orcamento_saude == max(orcamento_saude)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, orcamento_saude) |> 
  DT::datatable()
```

O município com o menor orçamento de saúde per capita é Igarape-ACU do Pará com RS 202,40.

```{r}
base_atributos |> 
  filter(orcamento_saude == min(orcamento_saude)) |> 
  select(nome, uf_destino, municipio_destino, populacao, pib_percapita, orcamento_saude) |> 
  DT::datatable()
```

#### 1.4.2.4 População atendida com esgotamento sanitário

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o SNIS do ano de 2020. O método de cálculo é: População total atendida com esgotamento sanitário ÷ População total do município (x100).

```{r}
esgoto_sanitario <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, esgotamento_sanitario) |> 
  mutate(id = substr(id, 1, 6))
  
base_atributos <- base_atributos |> 
  left_join(esgoto_sanitario, by = c("ibge_aloc" = "id")) |> 
  select(-Município)

cat("Média:", mean(base_atributos$esgotamento_sanitario))
```

A média da cobertura com esgoto sanitário dos municípios é de 24% e quando desagregado por churn é maior entre os que tiveram indivíduos que permaneceram.

```{r}

a <- base_atributos |> 
  ggplot(aes(x = esgotamento_sanitario,
             fill = churn)) +
  geom_boxplot() + 
  coord_flip() +
  theme(legend.position = "top") +
  theme(axis.text.x = element_blank()) +
  xlab("Percentual") +
  ylab("Esgotamento sanitário")

b <- base_atributos |> 
  ggplot(aes(x= esgotamento_sanitario)) + 
  geom_histogram() +
  xlab("Esgotamento sanitário") +
  ylab("Frequência")

a + b
```

Abaixo é possível observar que a média de cobertura de esgoto sanitário é ligeiramente maior entre os que migraram.

```{r}
base_atributos |> 
  group_by(churn) |> 
  summarise(esgotamento_sanitario = round(mean(esgotamento_sanitario),2)) |> 
  DT::datatable()
```

### 1.4.3 Indicadores de segurança pública

#### 1.4.3.1 Taxa de homicídio

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o DataSUS de 2019. O método de cálculo é: Número total de mortes por homicídio ÷ População total (x100.000).

```{r}
tx_homicidio <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, taxa_homicidio) |> 
  mutate(id = substr(id, 1, 6))

base_tratada20 <- base_tratada19 |> 
  left_join(tx_homicidio, by = c("codufmun" = "id")) |> 
  select(-Município)
```

#### 1.4.3.2 Mortes por armas de fogo

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o DataSUS de 2019. O método de cálculo é: Número de óbitos por armas de fogo ÷ População total do município (x100.000).

```{r}
armas_fogo <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, mortes_armasdefogo) |> 
  mutate(id = substr(id, 1, 6))

base_tratada21 <- base_tratada20 |> 
  left_join(armas_fogo, by = c("codufmun" = "id")) |> 
  select(-Município)
```

#### 1.4.3.3 Taxa de feminicídio

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o DataSUS de 2019. O método de cálculo é: Mortalidade por causas externas de mulheres ÷ Total de mulheres (x100.000).

```{r}
taxa_feminicidio <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, feminicidio) |> 
  mutate(id = substr(id, 1, 6))

base_tratada22 <- base_tratada21 |> 
  left_join(taxa_feminicidio, by = c("codufmun" = "id")) |> 
  select(-Município)
```

### 1.4.4 Indicadores de educação

#### 1.4.4.1 IDEB anos iniciais

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o MEC / IDEB de 2019. Método: Nota do Índice de Desenvolvimento da Educação Básica (IDEB) - Rede municipal - Anos Iniciais.

```{r}
ideb_inicio <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, ideb_anosiniciais) |> 
  mutate(id = substr(id, 1, 6))

base_tratada23 <- base_tratada22 |> 
  left_join(ideb_inicio, by = c("codufmun" = "id")) |> 
  select(-Município)
```

#### 1.4.4.1 IDEB anos finais

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o MEC / IDEB de 2019. Método: Nota do Índice de Desenvolvimento da Educação Básica (IDEB) - Rede municipal - Anos Iniciais.

```{r}
ideb_final <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, ideb_anosfinais) |> 
  mutate(id = substr(id, 1, 6))

base_tratada24 <- base_tratada23 |> 
  left_join(ideb_final, by = c("codufmun" = "id")) |> 
  select(-Município)
```

### 1.4.5 Indicadores de infraestrutura

#### 1.4.5.1 Investimento público em infraestrutura urbana por habitante

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é o SICONFI e IBGE PIB MUNICIPAL de 2019. Método: Valor do investimento público em infraestrutura ÷ Número de habitantes.

```{r}

infraestrutura <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, investimento_infraestrutura) |> 
  mutate(id = substr(id, 1, 6))

base_tratada25 <- base_tratada24 |> 
  left_join(infraestrutura, by = c("codufmun" = "id")) |> 
  select(-Município)
```

#### 1.4.5.2 Equipamentos esportivos municipais

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é a MUNIC de 2018. Método: Número total de equipamentos esportivos públicos ÷ População total do município (x100.000).

```{r}
equip_esportivos <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, equipamentos_esportivos) |> 
  mutate(id = substr(id, 1, 6))

base_tratada26 <- base_tratada25 |> 
  left_join(equip_esportivos, by = c("codufmun" = "id")) |> 
  select(-Município)
```

#### 1.4.5.3 Centros Culturais, casas e espaços de cultura

Este dado foi coletado do Índice de Desenvolvimento Sustentável das Cidades – Brasil (IDSC-BR), base de dados de 2022 no link: <https://www.cidadessustentaveis.org.br/paginas/idsc-br>. A fonte primária é a MUNIC de 2019. Método: Número de centros culturais, espaços e casas de cultura públicos e privados ÷ População total do município (x100.000).

```{r}
equip_culturais <- read_excel("~/GitHub/sa_maismedicos/01_dados/Editais/2019/indicadores_idsc_2022.xlsx") |> 
  select(id, Município, equpamentos_culturais) |> 
  mutate(id = substr(id, 1, 6))

base_tratada27 <- base_tratada26 |> 
  left_join(equip_culturais, by = c("codufmun" = "id")) |> 
  select(-Município)

base_tratada28 <- base_tratada27 |> 
  mutate(anos_atuacao_mesmo_municipio = ifelse(is.na(anos_atuacao), 0, anos_atuacao)) |> 
  select(-anos_atuacao)
```
