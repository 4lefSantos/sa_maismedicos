slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona a primeira ocorrência de cada CPF
ungroup() %>%
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-30")) %>%  # Filtra para quem começou entre 06/2019 e 11/2019
distinct(CPF_PROF)
teste <-base_tratada %>%
filter(CODUFMUN == ibge_aloc, TP_UNID == "02") %>%
group_by(CPF_PROF) %>%
slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona a primeira ocorrência de cada CPF
ungroup() %>%
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) %>%  # Filtra para quem começou entre 06/2019 e 11/2019
distinct(CPF_PROF)
View(teste)
View(cpf_validos)
cpf_validos <- base_tratada %>%
filter(CODUFMUN == ibge_aloc,
COMPETEN >= as.Date("2019-01-01"),
TP_UNID == "02") %>%
group_by(CPF_PROF) %>%
slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona a primeira ocorrência de cada CPF
ungroup() %>%
count(COMPETEN)
View(cpf_validos)
teste <-base_tratada %>%
filter(CODUFMUN == ibge_aloc, TP_UNID == "02") %>%
group_by(CPF_PROF) %>%
slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona o primeiro registro de cada CPF
ungroup() %>%
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-30")) %>%  # Filtra CPFs que começaram entre 06/2019 e 11/2019
count()
View(teste)
teste <-base_tratada %>%
filter(CODUFMUN == ibge_aloc, TP_UNID == "02") %>%
group_by(CPF_PROF) %>%
slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona o primeiro registro de cada CPF
ungroup() %>%
filter(COMPETEN <= as.Date("2019-11-30")) %>%  # Mantém CPFs com data de entrada até novembro de 2019
filter(COMPETEN >= as.Date("2019-06-01") | COMPETEN <= as.Date("2019-11-30")) %>%
distinct(CPF_PROF) %>%  # Remove duplicados de CPF
tally()
View(teste)
teste <-base_tratada %>%
filter(CODUFMUN == ibge_aloc, TP_UNID == "02") %>%
group_by(CPF_PROF) %>%
slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona o primeiro registro de cada CPF
ungroup() %>%
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-30")) %>%  # Filtra apenas CPFs que iniciaram entre 06/2019 e 11/2019
distinct(CPF_PROF) %>%
count()
View(teste)
teste <-base_tratada %>%
filter(CODUFMUN == ibge_aloc, TP_UNID == "02") %>%
group_by(CPF_PROF) %>%
slice_min(order_by = COMPETEN, n = 1) %>%  # Seleciona o primeiro registro de cada CPF
ungroup() %>%
filter(between(COMPETEN, as.Date("2019-06-01"), as.Date("2019-11-30"))) %>%  # Filtra CPFs que começaram entre 06/2019 e 11/2019
distinct(CPF_PROF) %>%
count()
View(teste)
teste <- base_tratada |>
mutate(pmmb = ifelse(CODUFMUN == ibge_aloc & TP_UNID == "02", "Sim", "Não"))
View(teste)
teste <- base_tratada |>
filter(COMPETEN => "2019-01-01")
teste <- base_tratada |>
filter(COMPETEN => as.Date("2019-01-01"))
teste <- base_tratada |>
filter(COMPETEN >= as.Date("2019-01-01"))
View(teste)
teste <- base_tratada |>
filter(COMPETEN >= as.Date("2019-01-01")) |>
mutate(pmmb = ifelse(CODUFMUN == ibge_aloc & TP_UNID == "02", "Sim", "Não"))
View(base_tratada)
View(teste)
cpf_validos <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slider_min(order_by = COMPETEN, n = 1)
cpf_validos <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1)
View(cpf_validos)
cpf_validos <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
group_by(COMPETEN) |>
count()
View(cpf_validos)
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN => as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN => as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
group_by(COMPETEN) |>
count()
View(aux)
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF)
group_by(COMPETEN) |>
count()
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
group_by(COMPETEN) |>
count()
View(aux)
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF)
View(aux)
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF) |>
count(COMPETEN)
View(aux)
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF) |>
group_by(COMPETEN) |>
count()
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
ungroup()
aux <- teste |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF)
base_tratada <- base_tratada |>
filter(COMPETEN >= as.Date("2019-01-01")) |>
mutate(pmmb = ifelse(CODUFMUN == ibge_aloc & TP_UNID == "02", "Sim", "Não"))
cpf_validos <- base_tratada |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF)
competen_inicio <- base_tratada |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1)
competen_inicio <- base_tratada |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
count(COMPETEN)
View(competen_inicio)
cpf_validos <- base_tratada |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF)
base_final <- base_tratada |>
filter(CPF_PROF %in% cpf_validos$CPF_PROF)
View(base_final)
cns_inscricao <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/Edital_11_2019_resultado_cns.xlsx") |>
select(nome,uf_aloc, municipio_aloc, ibge_aloc,participou_pmmb, data_nascimento, data_formacao, fase ,resultado) |>
rename(cns = resultado) |>
rename(municipio_destino = municipio_aloc) |>
rename(uf_destino = uf_aloc) |>
mutate(cns = as.character(cns)) |>
filter(!is.na(cns))
cns_inscricao <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/Edital_11_2019_resultado_cns.xlsx") |>
select(nome,uf_aloc, municipio_aloc, ibge_aloc,participou_pmmb, data_nascimento, data_formacao, fase ,resultado) |>
rename(cns = resultado) |>
rename(municipio_destino = municipio_aloc) |>
rename(uf_destino = uf_aloc) |>
mutate(cns = as.character(cns)) |>
filter(!is.na(cns)) |>
mutate(sexo = get_gender(cns_inscricao$nome)) |>
filter(!is.na(sexo))
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."Consulta_maismedicos_2019_cns"'
CNES_cns <- sqlQuery(channel, query,
as.is = TRUE)
#identificando os CPF
lista_cpf <- CNES_cns |>
filter(COMPETEN >= 201901) |>
mutate(CNS_PROF = as.character(CNS_PROF)) |>
select(CPF_PROF, CNS_PROF, NOMEPROF) |>
distinct(CPF_PROF)
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."Consulta_maismedicos_2019"'
CNES_cpf <- sqlQuery(channel, query,
as.is = TRUE)
lista_cns_cpf <- CNES_cns |>
filter(COMPETEN >= 201901) |>
mutate(CNS_PROF = as.character(CNS_PROF)) |>
select(CPF_PROF, CNS_PROF) |>
distinct(CPF_PROF, CNS_PROF)
cns_inscricao <- cns_inscricao |>
left_join(lista_cns_cpf, by = c("cns" = "CNS_PROF"))
base_tratada <-
CNES_cpf |>
left_join(cns_inscricao, by = c("CPF_PROF" = "CPF_PROF"))
prorrogacao_ciclo18 <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/prorrogacao_ciclo18.xlsx") |>
select(-CPF, -Ciclo)
prorrogacao_ciclo18 <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/prorrogacao_ciclo18.xlsx") |>
select(-CPF, -Ciclo)
prorrogacao_ciclo18 <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/prorrogacao_ciclo18.xlsx")
base_tratada <- base_tratada |>
left_join(prorrogacao_ciclo18, by = c("NOMEPROF" = "NOME")) |>
mutate(Prorrogado = ifelse(is.na(Prorrogado), "NÃO", Prorrogado))
View(base_tratada)
View(CNES_cns)
View(CNES_cpf)
View(base_tratada)
View(base_tratada)
compet_inicio <- base_tratada |>
filter(CODUFMUN == ibge_aloc, TP_UNID == "02") |>
group_by(COMPETEN, CNS_PROF) |>
ungroup(CNS_PROF) |>
distinct(CNS_PROF) |>
summarise(competencia_inicio = n())
View(compet_inicio)
base_tratada$COMPETEN <- as.Date(paste0(base_tratada$COMPETEN, "01"), format = "%Y%m%d")
# Convertendo a data de referência (competência) para o formato Date
competencia <- as.Date("2019-11-01")
# Calculando a idade em anos
base_tratada$idade <- trunc(as.numeric(interval(base_tratada$data_nascimento, competencia) / years(1)))
base_tratada$data_formacao <- as.Date(paste("01", base_tratada$data_formacao, sep = "/"), format = "%d/%m/%Y")
# Calculando o tempo de formação
base_tratada$tempo_formacao <- trunc(as.numeric(interval(base_tratada$data_formacao, competencia) / years(1)))
base_tratada <-base_tratada |>
mutate(estava_na_cidade = ifelse(COMPETEN == as.Date("2019-04-01") & CODUFMUN == ibge_aloc, "Sim", "Não"))
View(base_tratada)
lista_cnes <- base_tratada |>
distinct(CNES)
lista_municipios <- base_tratada |>
distinct(CODUFMUN)
#Carregando a base de contigente populacional
pop_mun <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/pop_municipios.xlsx") |>
mutate(cod_mun = substr(cod_mun, 1, 6)) |>
mutate(populacao = as.numeric(populacao))
base_tratada$CODUFMUN <- as.character(base_tratada$CODUFMUN)
base_tratada <- base_tratada |>
left_join(pop_mun, by = c("CODUFMUN" = "cod_mun")) |>
select(-mun)
#Classificando o porte dos municípios
base_tratada <- base_tratada |>
mutate(porte = case_when((populacao < 20000) ~ "PP-I",
(populacao >= 20000 & populacao < 50000) ~ "PP-II",
(populacao >= 50000 & populacao < 100000) ~ "MP",
(populacao >= 100000 & populacao < 900000) ~ "GP",
(populacao >= 900000) ~ "Metrópole",
TRUE ~ "Outros casos"))
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."pmmb_cobertura_plano_saude"'
cobertura_saude <- sqlQuery(channel, query,
as.is = TRUE)
View(cobertura_saude)
cobertura_saude <- cobertura_saude |>
rename(cobertura_saude = taxa) |>
mutate(cobertura_saude = as.numeric(cobertura_saude))
base_tratada <- base_tratada |>
left_join(cobertura_saude, by = c("CODUFMUN" = "cod_ibge"))
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."pmmb_vagas_medicina"'
vagas_medicina <- sqlQuery(channel, query,
as.is = TRUE)
base_tratada <- base_tratada |>
left_join(vagas_medicina, by = c("CODUFMUN" = "cod_ibge"))
base_tratada <- base_tratada |>
mutate(vagas_medicina = as.numeric(vagas_medicina)) |>
mutate(vagas_medicina_milhab = (vagas_medicina/populacao)*1000) |>
mutate(vagas_medicina = ifelse(is.na(vagas_medicina), 0, vagas_medicina)) |>
mutate(vagas_medicina_milhab = ifelse(is.na(vagas_medicina_milhab), 0, vagas_medicina_milhab))
View(base_tratada)
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."pmmb_pibpercapita"'
pib_percapita <- sqlQuery(channel, query,
as.is = TRUE)
base_tratada$ano_competencia <- year(base_tratada$COMPETEN)
pib_percapita <- pib_percapita |>
mutate(pib_percapita = as.numeric(pib_percapita)) |>
mutate(codigo_municipio = substring(codigo_municipio,1,6)) |>
mutate(ano = as.numeric(ano))
base_tratada <- base_tratada |>
left_join(pib_percapita, by = c("CODUFMUN" = "codigo_municipio", "ano_competencia" = "ano"))
View(base_tratada)
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."pmmb_leitos"'
leitos <- sqlQuery(channel, query,
as.is = TRUE)
View(leitos)
leitos <- leitos |>
select(cnes, ano, qt_total) |>
mutate(ano = as.numeric(ano))
base_tratada <- base_tratada |>
left_join(leitos, by = c("CNES" = "cnes", "ano_competencia" = "ano")) |>
rename(qt_leitos_cnes = qt_total) |>
mutate(qt_leitos_cnes = as.numeric(qt_leitos_cnes))
View(base_tratada)
# codigo para acessar dados de datalake proprio
dremio_host <- Sys.getenv("endereco")
dremio_port <- Sys.getenv("port")
dremio_uid <- Sys.getenv("uid")
dremio_pwd <- Sys.getenv("datalake")
channel <- odbcDriverConnect(sprintf("DRIVER=Dremio Connector;
HOST=%s;
PORT=%s;
UID=%s;
PWD=%s;
AUTHENTICATIONTYPE=Basic Authentication;
CONNECTIONTYPE=Direct",
dremio_host,
dremio_port,
dremio_uid,
dremio_pwd))
query <- 'SELECT * FROM "@alef_santos"."pmmb_equipe_cnes"'
equipe_saude <- sqlQuery(channel, query,
as.is = TRUE)
equipe_saude <- equipe_saude |>
select(CNES, ANO, categoria, FTE40) |>
mutate(categoria = case_when(categoria ==
"Técnico ou Auxiliar de Enfermagem" ~ "tec_aux_enf",
categoria == "Cirurgião Dentista" ~ "dentista",
categoria == "Agente Comunitário de Saúde" ~ "agente_saude",
categoria == "Enfermeiro" ~ "enfermeiro",
TRUE ~ NA)) |>
mutate(FTE40 = ifelse(is.na(FTE40), 0, FTE40))
equipe_saude <- equipe_saude |>
pivot_wider(names_from = categoria, values_from = FTE40) |>
mutate(across(3:6, ~ ifelse(is.na(.), 0, .))) |>
mutate(ANO = as.numeric(ANO))
base_tratada <- base_tratada |>
left_join(equipe_saude, by  = c("CNES" = "CNES", "ano_competencia" = "ANO"))
View(base_tratada)
pop_ocupada_mun <- read_excel("C:/Users/alefs/OneDrive/Documentos/GitHub/sa_maismedicos/01_dados/Editais/2019/pop_ocupada_mun.xlsx") |>
select(-municipio) |>
mutate(across(-cod_ibge, as.numeric)) |>  # Converte todas as colunas, exceto cod_ibge, para "character"
pivot_longer(
cols = -cod_ibge,
names_to = "ano",
values_to = "pop_ocupada"
) |>
mutate(ano = as.numeric(ano)) |>
mutate(cod_ibge = substring(cod_ibge,1,6))
base_tratada <- base_tratada |>
left_join(pop_ocupada_mun, by = c("CODUFMUN" = "cod_ibge", "ano_competencia" = "ano")) |>
mutate(tx_pop_ocupada = pop_ocupada/populacao)
View(base_tratada)
base_tratada <- base_tratada |>
filter(COMPETEN >= as.Date("2019-01-01")) |>
mutate(pmmb = ifelse(CODUFMUN == ibge_aloc & TP_UNID == "02", "Sim", "Não"))
compet_inicio <- base_tratada |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
count(COMPETEN)
View(compet_inicio)
cpf_validos <- base_tratada |>
filter(pmmb == "Sim") |>
group_by(CPF_PROF) |>
slice_min(order_by = COMPETEN, n = 1) |>
ungroup() |>
filter(COMPETEN >= as.Date("2019-06-01"), COMPETEN <= as.Date("2019-11-01")) |>
distinct(CPF_PROF)
base_final <- base_tratada |>
filter(CPF_PROF %in% cpf_validos$CPF_PROF)
View(base_final)
View(base_final)
teste <- base_final |>
mutate(across(37:41) ~ ifelse(is.na(.), 0, 0))
teste <- base_final |>
mutate(across(37:41), ~ ifelse(is.na(.), 0, 0))
teste <- base_final |>
mutate(across(37:41), ~ ifelse(is.na(.), 0, .))
teste <- base_final |>
mutate(across(37:41) ~ ifelse(is.na(.), 0, .))
teste <- base_final |>
mutate(across(37:41, ~ ifelse(is.na(.), 0, .)))
View(teste)
base_final <- base_final |>
mutate(across(37:41, ~ ifelse(is.na(.), 0, .)))
View(base_final)
